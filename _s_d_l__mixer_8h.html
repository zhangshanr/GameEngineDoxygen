<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CS5850: include/SDL3_mixer/SDL_mixer.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CS5850
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_f52e585a8d66b0e3c218422655eba69e.html">SDL3_mixer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">SDL_mixer.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Header file for SDL_mixer library.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;SDL3/SDL.h&gt;</code><br />
<code>#include &lt;SDL3/SDL_begin_code.h&gt;</code><br />
<code>#include &lt;SDL3/SDL_close_code.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for SDL_mixer.h:</div>
<div class="dyncontent">
<div class="center"><img src="_s_d_l__mixer_8h__incl.png" border="0" usemap="#ainclude_2_s_d_l3__mixer_2_s_d_l__mixer_8h" alt=""/></div>
<map name="ainclude_2_s_d_l3__mixer_2_s_d_l__mixer_8h" id="ainclude_2_s_d_l3__mixer_2_s_d_l__mixer_8h">
<area shape="rect" title="Header file for SDL_mixer library." alt="" coords="140,5,278,46"/>
<area shape="rect" title=" " alt="" coords="5,94,101,120"/>
<area shape="poly" title=" " alt="" coords="171,49,92,89,89,84,169,44"/>
<area shape="rect" title=" " alt="" coords="125,94,293,120"/>
<area shape="poly" title=" " alt="" coords="212,46,212,78,206,78,206,46"/>
<area shape="rect" title=" " alt="" coords="317,94,485,120"/>
<area shape="poly" title=" " alt="" coords="258,44,359,85,357,90,256,49"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="_s_d_l__mixer_8h__dep__incl.png" border="0" usemap="#ainclude_2_s_d_l3__mixer_2_s_d_l__mixer_8hdep" alt=""/></div>
<map name="ainclude_2_s_d_l3__mixer_2_s_d_l__mixer_8hdep" id="ainclude_2_s_d_l3__mixer_2_s_d_l__mixer_8hdep">
<area shape="rect" title="Header file for SDL_mixer library." alt="" coords="427,5,565,46"/>
<area shape="rect" href="_resource_manager_8hpp.html" title=" " alt="" coords="194,94,390,120"/>
<area shape="poly" title=" " alt="" coords="432,54,324,96,322,91,430,49"/>
<area shape="rect" href="_scene_8hpp.html" title=" " alt="" coords="432,94,560,120"/>
<area shape="poly" title=" " alt="" coords="499,62,499,93,493,93,493,62"/>
<area shape="rect" href="_scene_8cpp.html" title=" " alt="" coords="585,168,690,193"/>
<area shape="poly" title=" " alt="" coords="534,54,574,92,607,132,631,165,627,169,603,135,570,96,530,58"/>
<area shape="rect" href="_resource_manager_8cpp.html" title=" " alt="" coords="5,168,179,193"/>
<area shape="poly" title=" " alt="" coords="245,128,127,170,125,165,243,123"/>
<area shape="rect" href="_texture_component_8cpp.html" title=" " alt="" coords="203,168,381,193"/>
<area shape="poly" title=" " alt="" coords="295,135,295,167,289,167,289,135"/>
<area shape="rect" href="_application_8hpp.html" title=" " alt="" coords="405,168,560,193"/>
<area shape="poly" title=" " alt="" coords="494,135,488,168,482,167,488,134"/>
<area shape="poly" title=" " alt="" coords="535,125,614,165,612,169,532,129"/>
<area shape="rect" href="_application_8cpp.html" title=" " alt="" coords="347,241,480,267"/>
<area shape="poly" title=" " alt="" coords="463,206,427,243,423,239,459,202"/>
<area shape="rect" href="main_8cpp.html" title=" " alt="" coords="504,241,600,267"/>
<area shape="poly" title=" " alt="" coords="506,202,542,239,538,243,503,206"/>
</map>
</div>
</div>
<p><a href="_s_d_l__mixer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mix___chunk.html">Mix_Chunk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal format for an audio chunk.  <a href="struct_mix___chunk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a62af8116474da839221137996edf6a0e" id="r_a62af8116474da839221137996edf6a0e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62af8116474da839221137996edf6a0e">SDL_MIXER_MAJOR_VERSION</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a62af8116474da839221137996edf6a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Printable format: "%d.%d.%d", MAJOR, MINOR, PATCHLEVEL.  <br /></td></tr>
<tr class="separator:a62af8116474da839221137996edf6a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea96d57d92108eb55ced2900adef6a5" id="r_afea96d57d92108eb55ced2900adef6a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afea96d57d92108eb55ced2900adef6a5">SDL_MIXER_MINOR_VERSION</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:afea96d57d92108eb55ced2900adef6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00d5ae84eedcd8c85e5128625af3ddb" id="r_ac00d5ae84eedcd8c85e5128625af3ddb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac00d5ae84eedcd8c85e5128625af3ddb">SDL_MIXER_PATCHLEVEL</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ac00d5ae84eedcd8c85e5128625af3ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f12d4cf70382836dc0129afe796365" id="r_ad6f12d4cf70382836dc0129afe796365"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6f12d4cf70382836dc0129afe796365">SDL_MIXER_VERSION</a>(X)</td></tr>
<tr class="memdesc:ad6f12d4cf70382836dc0129afe796365"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro can be used to fill a version structure with the compile-time version of the SDL_mixer library.  <br /></td></tr>
<tr class="separator:ad6f12d4cf70382836dc0129afe796365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6a91becf98340310a774d66f18a775" id="r_a8a6a91becf98340310a774d66f18a775"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a6a91becf98340310a774d66f18a775">MIX_MAJOR_VERSION</a>&#160;&#160;&#160;<a class="el" href="#a62af8116474da839221137996edf6a0e">SDL_MIXER_MAJOR_VERSION</a></td></tr>
<tr class="separator:a8a6a91becf98340310a774d66f18a775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429f2a252000359a6538de6abd719c5f" id="r_a429f2a252000359a6538de6abd719c5f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a429f2a252000359a6538de6abd719c5f">MIX_MINOR_VERSION</a>&#160;&#160;&#160;<a class="el" href="#afea96d57d92108eb55ced2900adef6a5">SDL_MIXER_MINOR_VERSION</a></td></tr>
<tr class="separator:a429f2a252000359a6538de6abd719c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1975c52524c62a7b2b2ee3bb00a362af" id="r_a1975c52524c62a7b2b2ee3bb00a362af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1975c52524c62a7b2b2ee3bb00a362af">MIX_PATCHLEVEL</a>&#160;&#160;&#160;<a class="el" href="#ac00d5ae84eedcd8c85e5128625af3ddb">SDL_MIXER_PATCHLEVEL</a></td></tr>
<tr class="separator:a1975c52524c62a7b2b2ee3bb00a362af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8b3f1ee2d6372045cb0b2738ee868b" id="r_a3d8b3f1ee2d6372045cb0b2738ee868b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d8b3f1ee2d6372045cb0b2738ee868b">MIX_VERSION</a>(X)&#160;&#160;&#160;<a class="el" href="#ad6f12d4cf70382836dc0129afe796365">SDL_MIXER_VERSION</a>(X)</td></tr>
<tr class="separator:a3d8b3f1ee2d6372045cb0b2738ee868b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9e10cfedac69c7ef050c98e121461c" id="r_afd9e10cfedac69c7ef050c98e121461c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd9e10cfedac69c7ef050c98e121461c">SDL_MIXER_VERSION_ATLEAST</a>(X,  Y,  Z)</td></tr>
<tr class="memdesc:afd9e10cfedac69c7ef050c98e121461c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro will evaluate to true if compiled with SDL_mixer at least X.Y.Z.  <br /></td></tr>
<tr class="separator:afd9e10cfedac69c7ef050c98e121461c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4a8b188543964be1ab99d33685d921" id="r_a8b4a8b188543964be1ab99d33685d921"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b4a8b188543964be1ab99d33685d921">MIX_CHANNELS</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:a8b4a8b188543964be1ab99d33685d921"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default mixer has 8 simultaneous mixing channels.  <br /></td></tr>
<tr class="separator:a8b4a8b188543964be1ab99d33685d921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960c830f43ad3bd2b802f9fa35ff394f" id="r_a960c830f43ad3bd2b802f9fa35ff394f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a960c830f43ad3bd2b802f9fa35ff394f">MIX_DEFAULT_FREQUENCY</a>&#160;&#160;&#160;44100</td></tr>
<tr class="separator:a960c830f43ad3bd2b802f9fa35ff394f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0213e86be75a3b5bd28158a03cdb73" id="r_a9e0213e86be75a3b5bd28158a03cdb73"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e0213e86be75a3b5bd28158a03cdb73">MIX_DEFAULT_FORMAT</a>&#160;&#160;&#160;SDL_AUDIO_S16</td></tr>
<tr class="separator:a9e0213e86be75a3b5bd28158a03cdb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f2fc8f7be9e34899f044a5beada806" id="r_a31f2fc8f7be9e34899f044a5beada806"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31f2fc8f7be9e34899f044a5beada806">MIX_DEFAULT_CHANNELS</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a31f2fc8f7be9e34899f044a5beada806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ee7ce3c29e7fb4314edba1035c12b6" id="r_ac3ee7ce3c29e7fb4314edba1035c12b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3ee7ce3c29e7fb4314edba1035c12b6">MIX_MAX_VOLUME</a>&#160;&#160;&#160;SDL_MIX_MAXVOLUME /* Volume of a chunk */</td></tr>
<tr class="separator:ac3ee7ce3c29e7fb4314edba1035c12b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de550fb0c03378ab55cdf42c6e2fec9" id="r_a7de550fb0c03378ab55cdf42c6e2fec9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7de550fb0c03378ab55cdf42c6e2fec9">MIX_CHANNEL_POST</a>&#160;&#160;&#160;(-2)</td></tr>
<tr class="separator:a7de550fb0c03378ab55cdf42c6e2fec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb013a480a63af25255d0fa90ea9ab8" id="r_aabb013a480a63af25255d0fa90ea9ab8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabb013a480a63af25255d0fa90ea9ab8">MIX_EFFECTSMAXSPEED</a>&#160;&#160;&#160;&quot;MIX_EFFECTSMAXSPEED&quot;</td></tr>
<tr class="separator:aabb013a480a63af25255d0fa90ea9ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4c97802c19ab195d806459b7b520f7" id="r_afd4c97802c19ab195d806459b7b520f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd4c97802c19ab195d806459b7b520f7">Mix_SetError</a>&#160;&#160;&#160;SDL_SetError</td></tr>
<tr class="memdesc:afd4c97802c19ab195d806459b7b520f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report SDL_mixer errors.  <br /></td></tr>
<tr class="separator:afd4c97802c19ab195d806459b7b520f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29aa52963e2c1dd92888629c810c74f" id="r_ab29aa52963e2c1dd92888629c810c74f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab29aa52963e2c1dd92888629c810c74f">Mix_GetError</a>&#160;&#160;&#160;SDL_GetError</td></tr>
<tr class="memdesc:ab29aa52963e2c1dd92888629c810c74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get last SDL_mixer error.  <br /></td></tr>
<tr class="separator:ab29aa52963e2c1dd92888629c810c74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f49c5f9ea94150e3d1983d0a9652c6c" id="r_a6f49c5f9ea94150e3d1983d0a9652c6c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f49c5f9ea94150e3d1983d0a9652c6c">Mix_ClearError</a>&#160;&#160;&#160;SDL_ClearError</td></tr>
<tr class="memdesc:a6f49c5f9ea94150e3d1983d0a9652c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear last SDL_mixer error.  <br /></td></tr>
<tr class="separator:a6f49c5f9ea94150e3d1983d0a9652c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ee824416a5e227f17fb29bedc4455e" id="r_ae9ee824416a5e227f17fb29bedc4455e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9ee824416a5e227f17fb29bedc4455e">Mix_OutOfMemory</a>&#160;&#160;&#160;SDL_OutOfMemory</td></tr>
<tr class="memdesc:ae9ee824416a5e227f17fb29bedc4455e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set OutOfMemory error.  <br /></td></tr>
<tr class="separator:ae9ee824416a5e227f17fb29bedc4455e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2ad23aad3b0e340fbc73a9eef0b4228c" id="r_a2ad23aad3b0e340fbc73a9eef0b4228c"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#a3de2cd65e9533014d1bba145f6f2d36d">MIX_InitFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ad23aad3b0e340fbc73a9eef0b4228c">MIX_InitFlags</a></td></tr>
<tr class="memdesc:a2ad23aad3b0e340fbc73a9eef0b4228c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization flags.  <br /></td></tr>
<tr class="separator:a2ad23aad3b0e340fbc73a9eef0b4228c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec5298fec4179ed9c265e68f007755e" id="r_a0ec5298fec4179ed9c265e68f007755e"><td class="memItemLeft" align="right" valign="top">typedef struct Mix_Chunk&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ec5298fec4179ed9c265e68f007755e">Mix_Chunk</a></td></tr>
<tr class="memdesc:a0ec5298fec4179ed9c265e68f007755e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal format for an audio chunk.  <br /></td></tr>
<tr class="separator:a0ec5298fec4179ed9c265e68f007755e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9ac0ecc8a273861e44292905c24487" id="r_acb9ac0ecc8a273861e44292905c24487"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#a362f2bccb8d01c337b0c6a934edd456c">Mix_Fading</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb9ac0ecc8a273861e44292905c24487">Mix_Fading</a></td></tr>
<tr class="memdesc:acb9ac0ecc8a273861e44292905c24487"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different fading types supported.  <br /></td></tr>
<tr class="separator:acb9ac0ecc8a273861e44292905c24487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33487cba51a51972c7268f008039e30" id="r_af33487cba51a51972c7268f008039e30"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46">Mix_MusicType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af33487cba51a51972c7268f008039e30">Mix_MusicType</a></td></tr>
<tr class="memdesc:af33487cba51a51972c7268f008039e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are types of music files (not libraries used to load them)  <br /></td></tr>
<tr class="separator:af33487cba51a51972c7268f008039e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d58ae8fa29e1c03df23baeffb32b14c" id="r_a1d58ae8fa29e1c03df23baeffb32b14c"><td class="memItemLeft" align="right" valign="top">typedef struct _Mix_Music&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a></td></tr>
<tr class="memdesc:a1d58ae8fa29e1c03df23baeffb32b14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal format for a music chunk interpreted via codecs.  <br /></td></tr>
<tr class="separator:a1d58ae8fa29e1c03df23baeffb32b14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed80ffef737d37eefc7354e0ebff8c1b" id="r_aed80ffef737d37eefc7354e0ebff8c1b"><td class="memItemLeft" align="right" valign="top">typedef void(SDLCALL *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed80ffef737d37eefc7354e0ebff8c1b">Mix_EffectFunc_t</a>) (int chan, void *stream, int len, void *udata)</td></tr>
<tr class="memdesc:aed80ffef737d37eefc7354e0ebff8c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the format of a special effect callback:  <br /></td></tr>
<tr class="separator:aed80ffef737d37eefc7354e0ebff8c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac568739ba54c90964224a2b6365f61c7" id="r_ac568739ba54c90964224a2b6365f61c7"><td class="memItemLeft" align="right" valign="top">typedef void(SDLCALL *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac568739ba54c90964224a2b6365f61c7">Mix_EffectDone_t</a>) (int chan, void *udata)</td></tr>
<tr class="memdesc:ac568739ba54c90964224a2b6365f61c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a callback that signifies that a channel has finished all its loops and has completed playback.  <br /></td></tr>
<tr class="separator:ac568739ba54c90964224a2b6365f61c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3de2cd65e9533014d1bba145f6f2d36d" id="r_a3de2cd65e9533014d1bba145f6f2d36d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3de2cd65e9533014d1bba145f6f2d36d">MIX_InitFlags</a> { <br />
&#160;&#160;<a class="el" href="#a3de2cd65e9533014d1bba145f6f2d36dad2c4a750250632be803a8c4520d4c486">MIX_INIT_FLAC</a> = 0x00000001
, <a class="el" href="#a3de2cd65e9533014d1bba145f6f2d36dae3af2cbd16a150ae341f4286c0a5e394">MIX_INIT_MOD</a> = 0x00000002
, <a class="el" href="#a3de2cd65e9533014d1bba145f6f2d36daf439578078fa1f57ec9a09efe38ef24f">MIX_INIT_MP3</a> = 0x00000008
, <a class="el" href="#a3de2cd65e9533014d1bba145f6f2d36da2256680914b5648ffc8e54ab0bf4e00c">MIX_INIT_OGG</a> = 0x00000010
, <br />
&#160;&#160;<a class="el" href="#a3de2cd65e9533014d1bba145f6f2d36da70fbe004ddc741792efd399c7ce067a2">MIX_INIT_MID</a> = 0x00000020
, <a class="el" href="#a3de2cd65e9533014d1bba145f6f2d36dad4ef1e2599786b1d769766e6baa21d10">MIX_INIT_OPUS</a> = 0x00000040
, <a class="el" href="#a3de2cd65e9533014d1bba145f6f2d36da1aecb8b7037e750e8a38486f1f39a346">MIX_INIT_WAVPACK</a> = 0x00000080
<br />
 }</td></tr>
<tr class="memdesc:a3de2cd65e9533014d1bba145f6f2d36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization flags.  <a href="#a3de2cd65e9533014d1bba145f6f2d36d">More...</a><br /></td></tr>
<tr class="separator:a3de2cd65e9533014d1bba145f6f2d36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362f2bccb8d01c337b0c6a934edd456c" id="r_a362f2bccb8d01c337b0c6a934edd456c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a362f2bccb8d01c337b0c6a934edd456c">Mix_Fading</a> { <a class="el" href="#a362f2bccb8d01c337b0c6a934edd456ca81b8ccddd079a5f13aba7b21d1e475a4">MIX_NO_FADING</a>
, <a class="el" href="#a362f2bccb8d01c337b0c6a934edd456caa2d71aa2141ab0f2ff514f2c5d49a70c">MIX_FADING_OUT</a>
, <a class="el" href="#a362f2bccb8d01c337b0c6a934edd456cacac9dbc0a92b5116934dd4036e9e25ef">MIX_FADING_IN</a>
 }</td></tr>
<tr class="memdesc:a362f2bccb8d01c337b0c6a934edd456c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different fading types supported.  <a href="#a362f2bccb8d01c337b0c6a934edd456c">More...</a><br /></td></tr>
<tr class="separator:a362f2bccb8d01c337b0c6a934edd456c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3deb8c84c2e0a1bb970cd496d9e46f46" id="r_a3deb8c84c2e0a1bb970cd496d9e46f46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46">Mix_MusicType</a> { <br />
&#160;&#160;<a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46ad6c456444e9634514a07c31947bf51a7">MUS_NONE</a>
, <a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46a218a2952d564324cfc6fe78e4c598c39">MUS_CMD</a>
, <a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46ad2905fd8e5ac57321dea83f0afc8d7b6">MUS_WAV</a>
, <a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46aa1cd53bdbec42e838e5da8863741eae1">MUS_MOD</a>
, <br />
&#160;&#160;<a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46ac69784a48a28e2dafec3ef307ed0bf2b">MUS_MID</a>
, <a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46a9a80ce658507a45c33dd78c3a63deec2">MUS_OGG</a>
, <a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46a7edd0d75c1734063c604df8a11ef8a7a">MUS_MP3</a>
, <a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46a09f1e7e27da259c0ecd100fd3a216239">MUS_MP3_MAD_UNUSED</a>
, <br />
&#160;&#160;<a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46ac264a114cab6e312b12d8a88e14b8293">MUS_FLAC</a>
, <a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46a12fd85839605e40ff543b607da27a45e">MUS_MODPLUG_UNUSED</a>
, <a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46ae48bb4a7408f13511559e18ac68da401">MUS_OPUS</a>
, <a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46adb6c0b4f8f046dc130c58236968e5720">MUS_WAVPACK</a>
, <br />
&#160;&#160;<a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46a87e8a8b5695c2c352dc939cc92d80da6">MUS_GME</a>
<br />
 }</td></tr>
<tr class="memdesc:a3deb8c84c2e0a1bb970cd496d9e46f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are types of music files (not libraries used to load them)  <a href="#a3deb8c84c2e0a1bb970cd496d9e46f46">More...</a><br /></td></tr>
<tr class="separator:a3deb8c84c2e0a1bb970cd496d9e46f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2706949e601bd6ef831597074dd8c5fd" id="r_a2706949e601bd6ef831597074dd8c5fd"><td class="memItemLeft" align="right" valign="top">DECLSPEC const SDL_Version *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2706949e601bd6ef831597074dd8c5fd">Mix_Linked_Version</a> (void)</td></tr>
<tr class="memdesc:a2706949e601bd6ef831597074dd8c5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the version of SDL_mixer that the program is linked against.  <br /></td></tr>
<tr class="separator:a2706949e601bd6ef831597074dd8c5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a389ff8fb5e4af34d0951e73d05995" id="r_a71a389ff8fb5e4af34d0951e73d05995"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71a389ff8fb5e4af34d0951e73d05995">Mix_Init</a> (int flags)</td></tr>
<tr class="memdesc:a71a389ff8fb5e4af34d0951e73d05995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize SDL_mixer.  <br /></td></tr>
<tr class="separator:a71a389ff8fb5e4af34d0951e73d05995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136e5586b53fe0e3e752e2174bd7bb70" id="r_a136e5586b53fe0e3e752e2174bd7bb70"><td class="memItemLeft" align="right" valign="top">DECLSPEC void SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a136e5586b53fe0e3e752e2174bd7bb70">Mix_Quit</a> (void)</td></tr>
<tr class="memdesc:a136e5586b53fe0e3e752e2174bd7bb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize SDL_mixer.  <br /></td></tr>
<tr class="separator:a136e5586b53fe0e3e752e2174bd7bb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23afb407fa3a9766f21d07ea43bee1cd" id="r_a23afb407fa3a9766f21d07ea43bee1cd"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23afb407fa3a9766f21d07ea43bee1cd">Mix_OpenAudio</a> (SDL_AudioDeviceID devid, const SDL_AudioSpec *spec)</td></tr>
<tr class="memdesc:a23afb407fa3a9766f21d07ea43bee1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an audio device for playback.  <br /></td></tr>
<tr class="separator:a23afb407fa3a9766f21d07ea43bee1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a28d4294c7054944fced8b831f0b6b" id="r_a93a28d4294c7054944fced8b831f0b6b"><td class="memItemLeft" align="right" valign="top">DECLSPEC void SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93a28d4294c7054944fced8b831f0b6b">Mix_PauseAudio</a> (int pause_on)</td></tr>
<tr class="memdesc:a93a28d4294c7054944fced8b831f0b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend or resume the whole audio output.  <br /></td></tr>
<tr class="separator:a93a28d4294c7054944fced8b831f0b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f5c519bd9cbe0226b42a617b793cb8" id="r_ab9f5c519bd9cbe0226b42a617b793cb8"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9f5c519bd9cbe0226b42a617b793cb8">Mix_QuerySpec</a> (int *frequency, Uint16 *format, int *channels)</td></tr>
<tr class="memdesc:ab9f5c519bd9cbe0226b42a617b793cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out what the actual audio device parameters are.  <br /></td></tr>
<tr class="separator:ab9f5c519bd9cbe0226b42a617b793cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb24eade448b0c5515f9d402d935924" id="r_a3bb24eade448b0c5515f9d402d935924"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bb24eade448b0c5515f9d402d935924">Mix_AllocateChannels</a> (int numchans)</td></tr>
<tr class="memdesc:a3bb24eade448b0c5515f9d402d935924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically change the number of channels managed by the mixer.  <br /></td></tr>
<tr class="separator:a3bb24eade448b0c5515f9d402d935924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623ad2f07078a0b0c9c8758fb3cc8f84" id="r_a623ad2f07078a0b0c9c8758fb3cc8f84"><td class="memItemLeft" align="right" valign="top">DECLSPEC <a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a623ad2f07078a0b0c9c8758fb3cc8f84">Mix_LoadWAV_IO</a> (SDL_IOStream *src, SDL_bool closeio)</td></tr>
<tr class="memdesc:a623ad2f07078a0b0c9c8758fb3cc8f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a supported audio format into a chunk.  <br /></td></tr>
<tr class="separator:a623ad2f07078a0b0c9c8758fb3cc8f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad673a76d5638a3a5df0abab5af156d34" id="r_ad673a76d5638a3a5df0abab5af156d34"><td class="memItemLeft" align="right" valign="top">DECLSPEC <a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad673a76d5638a3a5df0abab5af156d34">Mix_LoadWAV</a> (const char *file)</td></tr>
<tr class="memdesc:ad673a76d5638a3a5df0abab5af156d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a supported audio format into a chunk.  <br /></td></tr>
<tr class="separator:ad673a76d5638a3a5df0abab5af156d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa283bfdf80dbb06db1548619fb3576ce" id="r_aa283bfdf80dbb06db1548619fb3576ce"><td class="memItemLeft" align="right" valign="top">DECLSPEC <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa283bfdf80dbb06db1548619fb3576ce">Mix_LoadMUS</a> (const char *file)</td></tr>
<tr class="memdesc:aa283bfdf80dbb06db1548619fb3576ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a supported audio format into a music object.  <br /></td></tr>
<tr class="separator:aa283bfdf80dbb06db1548619fb3576ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff11b875d98188f6a50fbff734139a0" id="r_abff11b875d98188f6a50fbff734139a0"><td class="memItemLeft" align="right" valign="top">DECLSPEC <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abff11b875d98188f6a50fbff734139a0">Mix_LoadMUS_IO</a> (SDL_IOStream *src, SDL_bool closeio)</td></tr>
<tr class="memdesc:abff11b875d98188f6a50fbff734139a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a supported audio format into a music object.  <br /></td></tr>
<tr class="separator:abff11b875d98188f6a50fbff734139a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba9978eb01d83cc0ad42ec36949781f" id="r_a1ba9978eb01d83cc0ad42ec36949781f"><td class="memItemLeft" align="right" valign="top">DECLSPEC <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ba9978eb01d83cc0ad42ec36949781f">Mix_LoadMUSType_IO</a> (SDL_IOStream *src, <a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46">Mix_MusicType</a> type, SDL_bool closeio)</td></tr>
<tr class="memdesc:a1ba9978eb01d83cc0ad42ec36949781f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load an audio format into a music object, assuming a specific format.  <br /></td></tr>
<tr class="separator:a1ba9978eb01d83cc0ad42ec36949781f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2833e2d174d29d32ac514574ee8866" id="r_a6a2833e2d174d29d32ac514574ee8866"><td class="memItemLeft" align="right" valign="top">DECLSPEC <a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a2833e2d174d29d32ac514574ee8866">Mix_QuickLoad_WAV</a> (Uint8 *mem)</td></tr>
<tr class="memdesc:a6a2833e2d174d29d32ac514574ee8866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a WAV file from memory as quickly as possible.  <br /></td></tr>
<tr class="separator:a6a2833e2d174d29d32ac514574ee8866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8da2bdfc6512b766235a3e9670462d" id="r_a1e8da2bdfc6512b766235a3e9670462d"><td class="memItemLeft" align="right" valign="top">DECLSPEC <a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e8da2bdfc6512b766235a3e9670462d">Mix_QuickLoad_RAW</a> (Uint8 *mem, Uint32 len)</td></tr>
<tr class="memdesc:a1e8da2bdfc6512b766235a3e9670462d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a raw audio data from memory as quickly as possible.  <br /></td></tr>
<tr class="separator:a1e8da2bdfc6512b766235a3e9670462d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7ae3433476bb4f66acedc6098e5b2d" id="r_abf7ae3433476bb4f66acedc6098e5b2d"><td class="memItemLeft" align="right" valign="top">DECLSPEC void SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf7ae3433476bb4f66acedc6098e5b2d">Mix_FreeChunk</a> (<a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *chunk)</td></tr>
<tr class="memdesc:abf7ae3433476bb4f66acedc6098e5b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an audio chunk.  <br /></td></tr>
<tr class="separator:abf7ae3433476bb4f66acedc6098e5b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e103808706941aab379d601a46327b" id="r_ac2e103808706941aab379d601a46327b"><td class="memItemLeft" align="right" valign="top">DECLSPEC void SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2e103808706941aab379d601a46327b">Mix_FreeMusic</a> (<a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *music)</td></tr>
<tr class="memdesc:ac2e103808706941aab379d601a46327b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a music object.  <br /></td></tr>
<tr class="separator:ac2e103808706941aab379d601a46327b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a0798b1d506b9231fc8bf249cc205a" id="r_a96a0798b1d506b9231fc8bf249cc205a"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96a0798b1d506b9231fc8bf249cc205a">Mix_GetNumChunkDecoders</a> (void)</td></tr>
<tr class="memdesc:a96a0798b1d506b9231fc8bf249cc205a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of chunk decoders that this build of SDL_mixer provides.  <br /></td></tr>
<tr class="separator:a96a0798b1d506b9231fc8bf249cc205a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa645fef7a0febfb5a841eca0585e7d" id="r_a3aa645fef7a0febfb5a841eca0585e7d"><td class="memItemLeft" align="right" valign="top">DECLSPEC const char *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aa645fef7a0febfb5a841eca0585e7d">Mix_GetChunkDecoder</a> (int index)</td></tr>
<tr class="memdesc:a3aa645fef7a0febfb5a841eca0585e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a chunk decoder's name.  <br /></td></tr>
<tr class="separator:a3aa645fef7a0febfb5a841eca0585e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d47159d90b111fdb8b76002519d4e57" id="r_a4d47159d90b111fdb8b76002519d4e57"><td class="memItemLeft" align="right" valign="top">DECLSPEC SDL_bool SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d47159d90b111fdb8b76002519d4e57">Mix_HasChunkDecoder</a> (const char *name)</td></tr>
<tr class="memdesc:a4d47159d90b111fdb8b76002519d4e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a chunk decoder is available by name.  <br /></td></tr>
<tr class="separator:a4d47159d90b111fdb8b76002519d4e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9256e344e9916e15764a4e39d428de" id="r_acd9256e344e9916e15764a4e39d428de"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd9256e344e9916e15764a4e39d428de">Mix_GetNumMusicDecoders</a> (void)</td></tr>
<tr class="memdesc:acd9256e344e9916e15764a4e39d428de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of music decoders that this build of SDL_mixer provides.  <br /></td></tr>
<tr class="separator:acd9256e344e9916e15764a4e39d428de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373d0fa4f158f0731564710d547c9a17" id="r_a373d0fa4f158f0731564710d547c9a17"><td class="memItemLeft" align="right" valign="top">DECLSPEC const char *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a373d0fa4f158f0731564710d547c9a17">Mix_GetMusicDecoder</a> (int index)</td></tr>
<tr class="memdesc:a373d0fa4f158f0731564710d547c9a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a music decoder's name.  <br /></td></tr>
<tr class="separator:a373d0fa4f158f0731564710d547c9a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebece8a3134f9bdf850997af8c479163" id="r_aebece8a3134f9bdf850997af8c479163"><td class="memItemLeft" align="right" valign="top">DECLSPEC SDL_bool SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebece8a3134f9bdf850997af8c479163">Mix_HasMusicDecoder</a> (const char *name)</td></tr>
<tr class="memdesc:aebece8a3134f9bdf850997af8c479163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a music decoder is available by name.  <br /></td></tr>
<tr class="separator:aebece8a3134f9bdf850997af8c479163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067102de8c25361537caa4165ce5eeae" id="r_a067102de8c25361537caa4165ce5eeae"><td class="memItemLeft" align="right" valign="top">DECLSPEC <a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46">Mix_MusicType</a> SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a067102de8c25361537caa4165ce5eeae">Mix_GetMusicType</a> (const <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *music)</td></tr>
<tr class="memdesc:a067102de8c25361537caa4165ce5eeae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out the format of a mixer music.  <br /></td></tr>
<tr class="separator:a067102de8c25361537caa4165ce5eeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa549f3835d4695340f687d1c381b8a" id="r_a8aa549f3835d4695340f687d1c381b8a"><td class="memItemLeft" align="right" valign="top">DECLSPEC const char *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8aa549f3835d4695340f687d1c381b8a">Mix_GetMusicTitle</a> (const <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *music)</td></tr>
<tr class="memdesc:a8aa549f3835d4695340f687d1c381b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the title for a music object, or its filename.  <br /></td></tr>
<tr class="separator:a8aa549f3835d4695340f687d1c381b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285662440916db1fa0949ab7e48e7e90" id="r_a285662440916db1fa0949ab7e48e7e90"><td class="memItemLeft" align="right" valign="top">DECLSPEC const char *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a285662440916db1fa0949ab7e48e7e90">Mix_GetMusicTitleTag</a> (const <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *music)</td></tr>
<tr class="memdesc:a285662440916db1fa0949ab7e48e7e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the title for a music object.  <br /></td></tr>
<tr class="separator:a285662440916db1fa0949ab7e48e7e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985ef119ec4cc0f52f0e848930cc20d6" id="r_a985ef119ec4cc0f52f0e848930cc20d6"><td class="memItemLeft" align="right" valign="top">DECLSPEC const char *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a985ef119ec4cc0f52f0e848930cc20d6">Mix_GetMusicArtistTag</a> (const <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *music)</td></tr>
<tr class="memdesc:a985ef119ec4cc0f52f0e848930cc20d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the artist name for a music object.  <br /></td></tr>
<tr class="separator:a985ef119ec4cc0f52f0e848930cc20d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d322897b0c7700311df2dd835ab027" id="r_a00d322897b0c7700311df2dd835ab027"><td class="memItemLeft" align="right" valign="top">DECLSPEC const char *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00d322897b0c7700311df2dd835ab027">Mix_GetMusicAlbumTag</a> (const <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *music)</td></tr>
<tr class="memdesc:a00d322897b0c7700311df2dd835ab027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the album name for a music object.  <br /></td></tr>
<tr class="separator:a00d322897b0c7700311df2dd835ab027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327b3dcabc52c4a92f7d2ba4a9a8bde9" id="r_a327b3dcabc52c4a92f7d2ba4a9a8bde9"><td class="memItemLeft" align="right" valign="top">DECLSPEC const char *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a327b3dcabc52c4a92f7d2ba4a9a8bde9">Mix_GetMusicCopyrightTag</a> (const <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *music)</td></tr>
<tr class="memdesc:a327b3dcabc52c4a92f7d2ba4a9a8bde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the copyright text for a music object.  <br /></td></tr>
<tr class="separator:a327b3dcabc52c4a92f7d2ba4a9a8bde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc4ec0f09fd676d9d7569550d866ca7" id="r_a7dc4ec0f09fd676d9d7569550d866ca7"><td class="memItemLeft" align="right" valign="top">DECLSPEC void SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dc4ec0f09fd676d9d7569550d866ca7">Mix_SetPostMix</a> (void(SDLCALL *mix_func)(void *udata, Uint8 *stream, int len), void *arg)</td></tr>
<tr class="memdesc:a7dc4ec0f09fd676d9d7569550d866ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a function that is called after all mixing is performed.  <br /></td></tr>
<tr class="separator:a7dc4ec0f09fd676d9d7569550d866ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7889c7e4fd6c846e6ddf68a6b8eb12" id="r_a9c7889c7e4fd6c846e6ddf68a6b8eb12"><td class="memItemLeft" align="right" valign="top">DECLSPEC void SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c7889c7e4fd6c846e6ddf68a6b8eb12">Mix_HookMusic</a> (void(SDLCALL *mix_func)(void *udata, Uint8 *stream, int len), void *arg)</td></tr>
<tr class="memdesc:a9c7889c7e4fd6c846e6ddf68a6b8eb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add your own music player or additional mixer function.  <br /></td></tr>
<tr class="separator:a9c7889c7e4fd6c846e6ddf68a6b8eb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab715ac2972aed61a2eaff4f980beb594" id="r_ab715ac2972aed61a2eaff4f980beb594"><td class="memItemLeft" align="right" valign="top">DECLSPEC void SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab715ac2972aed61a2eaff4f980beb594">Mix_HookMusicFinished</a> (void(SDLCALL *music_finished)(void))</td></tr>
<tr class="memdesc:ab715ac2972aed61a2eaff4f980beb594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a callback that runs when a music object has stopped playing.  <br /></td></tr>
<tr class="separator:ab715ac2972aed61a2eaff4f980beb594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7de033c57de248ad0737b710e64cd5c" id="r_ac7de033c57de248ad0737b710e64cd5c"><td class="memItemLeft" align="right" valign="top">DECLSPEC void *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7de033c57de248ad0737b710e64cd5c">Mix_GetMusicHookData</a> (void)</td></tr>
<tr class="memdesc:ac7de033c57de248ad0737b710e64cd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the user data for the current music hook.  <br /></td></tr>
<tr class="separator:ac7de033c57de248ad0737b710e64cd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb79c6f792464428d51b6aba1088b77" id="r_a8bb79c6f792464428d51b6aba1088b77"><td class="memItemLeft" align="right" valign="top">DECLSPEC void SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bb79c6f792464428d51b6aba1088b77">Mix_ChannelFinished</a> (void(SDLCALL *channel_finished)(int channel))</td></tr>
<tr class="memdesc:a8bb79c6f792464428d51b6aba1088b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a callback that runs when a channel has finished playing.  <br /></td></tr>
<tr class="separator:a8bb79c6f792464428d51b6aba1088b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3843504b9dfb94b22d4f74721adebf8" id="r_aa3843504b9dfb94b22d4f74721adebf8"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3843504b9dfb94b22d4f74721adebf8">Mix_RegisterEffect</a> (int chan, <a class="el" href="#aed80ffef737d37eefc7354e0ebff8c1b">Mix_EffectFunc_t</a> f, <a class="el" href="#ac568739ba54c90964224a2b6365f61c7">Mix_EffectDone_t</a> d, void *arg)</td></tr>
<tr class="memdesc:aa3843504b9dfb94b22d4f74721adebf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a special effect function.  <br /></td></tr>
<tr class="separator:aa3843504b9dfb94b22d4f74721adebf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c460b5c391b7037156adcc47d5ba2c5" id="r_a3c460b5c391b7037156adcc47d5ba2c5"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c460b5c391b7037156adcc47d5ba2c5">Mix_UnregisterEffect</a> (int channel, <a class="el" href="#aed80ffef737d37eefc7354e0ebff8c1b">Mix_EffectFunc_t</a> f)</td></tr>
<tr class="memdesc:a3c460b5c391b7037156adcc47d5ba2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly unregister a special effect function.  <br /></td></tr>
<tr class="separator:a3c460b5c391b7037156adcc47d5ba2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3591d82e9975a21317865850644e1bf8" id="r_a3591d82e9975a21317865850644e1bf8"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3591d82e9975a21317865850644e1bf8">Mix_UnregisterAllEffects</a> (int channel)</td></tr>
<tr class="memdesc:a3591d82e9975a21317865850644e1bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly unregister all special effect functions.  <br /></td></tr>
<tr class="separator:a3591d82e9975a21317865850644e1bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896c0ac1043249dfbf1bc758297f54f2" id="r_a896c0ac1043249dfbf1bc758297f54f2"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a896c0ac1043249dfbf1bc758297f54f2">Mix_SetPanning</a> (int channel, Uint8 left, Uint8 right)</td></tr>
<tr class="memdesc:a896c0ac1043249dfbf1bc758297f54f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the panning of a channel.  <br /></td></tr>
<tr class="separator:a896c0ac1043249dfbf1bc758297f54f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3708de5fc6fc191bb691e972f257a63d" id="r_a3708de5fc6fc191bb691e972f257a63d"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3708de5fc6fc191bb691e972f257a63d">Mix_SetPosition</a> (int channel, Sint16 angle, Uint8 distance)</td></tr>
<tr class="memdesc:a3708de5fc6fc191bb691e972f257a63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the position of a channel.  <br /></td></tr>
<tr class="separator:a3708de5fc6fc191bb691e972f257a63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a244386902034964e4c5f5bcfef808" id="r_a36a244386902034964e4c5f5bcfef808"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36a244386902034964e4c5f5bcfef808">Mix_SetDistance</a> (int channel, Uint8 distance)</td></tr>
<tr class="memdesc:a36a244386902034964e4c5f5bcfef808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the "distance" of a channel.  <br /></td></tr>
<tr class="separator:a36a244386902034964e4c5f5bcfef808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26962e9d1fe6c9bdf249237433bf109" id="r_ae26962e9d1fe6c9bdf249237433bf109"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae26962e9d1fe6c9bdf249237433bf109">Mix_SetReverseStereo</a> (int channel, int flip)</td></tr>
<tr class="memdesc:ae26962e9d1fe6c9bdf249237433bf109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause a channel to reverse its stereo.  <br /></td></tr>
<tr class="separator:ae26962e9d1fe6c9bdf249237433bf109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d97b94207796ae479f7599a0b3a89e" id="r_af5d97b94207796ae479f7599a0b3a89e"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5d97b94207796ae479f7599a0b3a89e">Mix_ReserveChannels</a> (int num)</td></tr>
<tr class="memdesc:af5d97b94207796ae479f7599a0b3a89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve the first channels for the application.  <br /></td></tr>
<tr class="separator:af5d97b94207796ae479f7599a0b3a89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ce85d3ea72e1d14e1fbd15bbf8cfd1" id="r_ab0ce85d3ea72e1d14e1fbd15bbf8cfd1"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0ce85d3ea72e1d14e1fbd15bbf8cfd1">Mix_GroupChannel</a> (int which, int tag)</td></tr>
<tr class="memdesc:ab0ce85d3ea72e1d14e1fbd15bbf8cfd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a tag to a channel.  <br /></td></tr>
<tr class="separator:ab0ce85d3ea72e1d14e1fbd15bbf8cfd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8ff77b8e446e449701371a0c8cc522" id="r_aee8ff77b8e446e449701371a0c8cc522"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee8ff77b8e446e449701371a0c8cc522">Mix_GroupChannels</a> (int from, int to, int tag)</td></tr>
<tr class="memdesc:aee8ff77b8e446e449701371a0c8cc522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign several consecutive channels to the same tag.  <br /></td></tr>
<tr class="separator:aee8ff77b8e446e449701371a0c8cc522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b751351d0554c264a0d1abc02d832c" id="r_ae4b751351d0554c264a0d1abc02d832c"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4b751351d0554c264a0d1abc02d832c">Mix_GroupAvailable</a> (int tag)</td></tr>
<tr class="memdesc:ae4b751351d0554c264a0d1abc02d832c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first available channel in a group of channels.  <br /></td></tr>
<tr class="separator:ae4b751351d0554c264a0d1abc02d832c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ca84ed285330500b98b7731710e26f" id="r_a43ca84ed285330500b98b7731710e26f"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43ca84ed285330500b98b7731710e26f">Mix_GroupCount</a> (int tag)</td></tr>
<tr class="memdesc:a43ca84ed285330500b98b7731710e26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of channels in a group.  <br /></td></tr>
<tr class="separator:a43ca84ed285330500b98b7731710e26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e7c63dab34fa0a964442e90fd4d416" id="r_a97e7c63dab34fa0a964442e90fd4d416"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97e7c63dab34fa0a964442e90fd4d416">Mix_GroupOldest</a> (int tag)</td></tr>
<tr class="memdesc:a97e7c63dab34fa0a964442e90fd4d416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the "oldest" sample playing in a group of channels.  <br /></td></tr>
<tr class="separator:a97e7c63dab34fa0a964442e90fd4d416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598ff819d5c839f199183ed997855d83" id="r_a598ff819d5c839f199183ed997855d83"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a598ff819d5c839f199183ed997855d83">Mix_GroupNewer</a> (int tag)</td></tr>
<tr class="memdesc:a598ff819d5c839f199183ed997855d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the "most recent" sample playing in a group of channels.  <br /></td></tr>
<tr class="separator:a598ff819d5c839f199183ed997855d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f0143230493220f052f50e1cabc070" id="r_af9f0143230493220f052f50e1cabc070"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9f0143230493220f052f50e1cabc070">Mix_PlayChannel</a> (int channel, <a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *chunk, int loops)</td></tr>
<tr class="memdesc:af9f0143230493220f052f50e1cabc070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Play an audio chunk on a specific channel.  <br /></td></tr>
<tr class="separator:af9f0143230493220f052f50e1cabc070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7e5bb8d3dbd3539eb3d032589fc624" id="r_a9e7e5bb8d3dbd3539eb3d032589fc624"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e7e5bb8d3dbd3539eb3d032589fc624">Mix_PlayChannelTimed</a> (int channel, <a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *chunk, int loops, int ticks)</td></tr>
<tr class="memdesc:a9e7e5bb8d3dbd3539eb3d032589fc624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Play an audio chunk on a specific channel for a maximum time.  <br /></td></tr>
<tr class="separator:a9e7e5bb8d3dbd3539eb3d032589fc624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215ea5402d7da6d73a53b408d33b06b3" id="r_a215ea5402d7da6d73a53b408d33b06b3"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a215ea5402d7da6d73a53b408d33b06b3">Mix_PlayMusic</a> (<a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *music, int loops)</td></tr>
<tr class="memdesc:a215ea5402d7da6d73a53b408d33b06b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Play a new music object.  <br /></td></tr>
<tr class="separator:a215ea5402d7da6d73a53b408d33b06b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2400bb4d58a5bce5e1c734f2b09bface" id="r_a2400bb4d58a5bce5e1c734f2b09bface"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2400bb4d58a5bce5e1c734f2b09bface">Mix_FadeInMusic</a> (<a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *music, int loops, int ms)</td></tr>
<tr class="memdesc:a2400bb4d58a5bce5e1c734f2b09bface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Play a new music object, fading in the audio.  <br /></td></tr>
<tr class="separator:a2400bb4d58a5bce5e1c734f2b09bface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636e248dd7cd411c3edcebd2c74db71e" id="r_a636e248dd7cd411c3edcebd2c74db71e"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a636e248dd7cd411c3edcebd2c74db71e">Mix_FadeInMusicPos</a> (<a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *music, int loops, int ms, double position)</td></tr>
<tr class="memdesc:a636e248dd7cd411c3edcebd2c74db71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Play a new music object, fading in the audio, from a starting position.  <br /></td></tr>
<tr class="separator:a636e248dd7cd411c3edcebd2c74db71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e6b40eb77070b3e74f4f7c1669acbd" id="r_ab7e6b40eb77070b3e74f4f7c1669acbd"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7e6b40eb77070b3e74f4f7c1669acbd">Mix_FadeInChannel</a> (int channel, <a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *chunk, int loops, int ms)</td></tr>
<tr class="memdesc:ab7e6b40eb77070b3e74f4f7c1669acbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Play an audio chunk on a specific channel, fading in the audio.  <br /></td></tr>
<tr class="separator:ab7e6b40eb77070b3e74f4f7c1669acbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb54ff92263b255ec013cdd1ee21d9e" id="r_a1fb54ff92263b255ec013cdd1ee21d9e"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fb54ff92263b255ec013cdd1ee21d9e">Mix_FadeInChannelTimed</a> (int channel, <a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *chunk, int loops, int ms, int ticks)</td></tr>
<tr class="memdesc:a1fb54ff92263b255ec013cdd1ee21d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Play an audio chunk on a specific channel, fading in the audio, for a maximum time.  <br /></td></tr>
<tr class="separator:a1fb54ff92263b255ec013cdd1ee21d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d2418a357057d2aabad338476e1b9a" id="r_a41d2418a357057d2aabad338476e1b9a"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41d2418a357057d2aabad338476e1b9a">Mix_Volume</a> (int channel, int volume)</td></tr>
<tr class="memdesc:a41d2418a357057d2aabad338476e1b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the volume for a specific channel.  <br /></td></tr>
<tr class="separator:a41d2418a357057d2aabad338476e1b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d54b34877f1187d4789884cbaff8be2" id="r_a4d54b34877f1187d4789884cbaff8be2"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d54b34877f1187d4789884cbaff8be2">Mix_VolumeChunk</a> (<a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *chunk, int volume)</td></tr>
<tr class="memdesc:a4d54b34877f1187d4789884cbaff8be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the volume for a specific chunk.  <br /></td></tr>
<tr class="separator:a4d54b34877f1187d4789884cbaff8be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab926fc25eab93de464ac7029e2125003" id="r_ab926fc25eab93de464ac7029e2125003"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab926fc25eab93de464ac7029e2125003">Mix_VolumeMusic</a> (int volume)</td></tr>
<tr class="memdesc:ab926fc25eab93de464ac7029e2125003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the volume for the music channel.  <br /></td></tr>
<tr class="separator:ab926fc25eab93de464ac7029e2125003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ae48f64daaef414b1cd9255de4c26d" id="r_ad7ae48f64daaef414b1cd9255de4c26d"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7ae48f64daaef414b1cd9255de4c26d">Mix_GetMusicVolume</a> (<a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *music)</td></tr>
<tr class="memdesc:ad7ae48f64daaef414b1cd9255de4c26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the current volume value for a music object.  <br /></td></tr>
<tr class="separator:ad7ae48f64daaef414b1cd9255de4c26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5704e4a69605a6d7089d1d21860ea921" id="r_a5704e4a69605a6d7089d1d21860ea921"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5704e4a69605a6d7089d1d21860ea921">Mix_MasterVolume</a> (int volume)</td></tr>
<tr class="memdesc:a5704e4a69605a6d7089d1d21860ea921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the master volume for all channels.  <br /></td></tr>
<tr class="separator:a5704e4a69605a6d7089d1d21860ea921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369f1cc25e69d0dc2a6f652109de9683" id="r_a369f1cc25e69d0dc2a6f652109de9683"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a369f1cc25e69d0dc2a6f652109de9683">Mix_HaltChannel</a> (int channel)</td></tr>
<tr class="memdesc:a369f1cc25e69d0dc2a6f652109de9683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt playing of a particular channel.  <br /></td></tr>
<tr class="separator:a369f1cc25e69d0dc2a6f652109de9683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f97cb41be6a1b4c3d638cc9aaa7043" id="r_ab3f97cb41be6a1b4c3d638cc9aaa7043"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3f97cb41be6a1b4c3d638cc9aaa7043">Mix_HaltGroup</a> (int tag)</td></tr>
<tr class="memdesc:ab3f97cb41be6a1b4c3d638cc9aaa7043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt playing of a group of channels by arbitrary tag.  <br /></td></tr>
<tr class="separator:ab3f97cb41be6a1b4c3d638cc9aaa7043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2bc73786ee25eddb63208751baba76" id="r_a2b2bc73786ee25eddb63208751baba76"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b2bc73786ee25eddb63208751baba76">Mix_HaltMusic</a> (void)</td></tr>
<tr class="memdesc:a2b2bc73786ee25eddb63208751baba76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt playing of the music stream.  <br /></td></tr>
<tr class="separator:a2b2bc73786ee25eddb63208751baba76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca9a903a8f102404d9f588b83fec7fe" id="r_a5ca9a903a8f102404d9f588b83fec7fe"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ca9a903a8f102404d9f588b83fec7fe">Mix_ExpireChannel</a> (int channel, int ticks)</td></tr>
<tr class="memdesc:a5ca9a903a8f102404d9f588b83fec7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the expiration delay for a particular channel.  <br /></td></tr>
<tr class="separator:a5ca9a903a8f102404d9f588b83fec7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4743866ba2f907858de7fa2ef6108f" id="r_ace4743866ba2f907858de7fa2ef6108f"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace4743866ba2f907858de7fa2ef6108f">Mix_FadeOutChannel</a> (int which, int ms)</td></tr>
<tr class="memdesc:ace4743866ba2f907858de7fa2ef6108f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt a channel after fading it out for a specified time.  <br /></td></tr>
<tr class="separator:ace4743866ba2f907858de7fa2ef6108f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62361006702546e9d66021c0c9f5a5b" id="r_ab62361006702546e9d66021c0c9f5a5b"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab62361006702546e9d66021c0c9f5a5b">Mix_FadeOutGroup</a> (int tag, int ms)</td></tr>
<tr class="memdesc:ab62361006702546e9d66021c0c9f5a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt a playing group of channels by arbitrary tag, after fading them out for a specified time.  <br /></td></tr>
<tr class="separator:ab62361006702546e9d66021c0c9f5a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8cc2e99284bf7268b1ee62b86b5367" id="r_aff8cc2e99284bf7268b1ee62b86b5367"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff8cc2e99284bf7268b1ee62b86b5367">Mix_FadeOutMusic</a> (int ms)</td></tr>
<tr class="memdesc:aff8cc2e99284bf7268b1ee62b86b5367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt the music stream after fading it out for a specified time.  <br /></td></tr>
<tr class="separator:aff8cc2e99284bf7268b1ee62b86b5367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb499a0686c714ede299e81e85c817c" id="r_afcb499a0686c714ede299e81e85c817c"><td class="memItemLeft" align="right" valign="top">DECLSPEC <a class="el" href="#a362f2bccb8d01c337b0c6a934edd456c">Mix_Fading</a> SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcb499a0686c714ede299e81e85c817c">Mix_FadingMusic</a> (void)</td></tr>
<tr class="memdesc:afcb499a0686c714ede299e81e85c817c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the fading status of the music stream.  <br /></td></tr>
<tr class="separator:afcb499a0686c714ede299e81e85c817c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffa4c64b29f638f549defecdf7d9ddd" id="r_aeffa4c64b29f638f549defecdf7d9ddd"><td class="memItemLeft" align="right" valign="top">DECLSPEC <a class="el" href="#a362f2bccb8d01c337b0c6a934edd456c">Mix_Fading</a> SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeffa4c64b29f638f549defecdf7d9ddd">Mix_FadingChannel</a> (int which)</td></tr>
<tr class="memdesc:aeffa4c64b29f638f549defecdf7d9ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the fading status of a channel.  <br /></td></tr>
<tr class="separator:aeffa4c64b29f638f549defecdf7d9ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8327a4a060ebc4dc1771db7a3e9d3038" id="r_a8327a4a060ebc4dc1771db7a3e9d3038"><td class="memItemLeft" align="right" valign="top">DECLSPEC void SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8327a4a060ebc4dc1771db7a3e9d3038">Mix_Pause</a> (int channel)</td></tr>
<tr class="memdesc:a8327a4a060ebc4dc1771db7a3e9d3038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause a particular channel.  <br /></td></tr>
<tr class="separator:a8327a4a060ebc4dc1771db7a3e9d3038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb401349586584fd1635b692732479c2" id="r_acb401349586584fd1635b692732479c2"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb401349586584fd1635b692732479c2">Mix_PauseGroup</a> (int tag)</td></tr>
<tr class="memdesc:acb401349586584fd1635b692732479c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause playing of a group of channels by arbitrary tag.  <br /></td></tr>
<tr class="separator:acb401349586584fd1635b692732479c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f6a115fe2ffb8488929d96e8575d70" id="r_aa5f6a115fe2ffb8488929d96e8575d70"><td class="memItemLeft" align="right" valign="top">DECLSPEC void SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5f6a115fe2ffb8488929d96e8575d70">Mix_Resume</a> (int channel)</td></tr>
<tr class="memdesc:aa5f6a115fe2ffb8488929d96e8575d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a particular channel.  <br /></td></tr>
<tr class="separator:aa5f6a115fe2ffb8488929d96e8575d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b6ac6a764dffe3005ea16341d9d044" id="r_aa5b6ac6a764dffe3005ea16341d9d044"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5b6ac6a764dffe3005ea16341d9d044">Mix_ResumeGroup</a> (int tag)</td></tr>
<tr class="memdesc:aa5b6ac6a764dffe3005ea16341d9d044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume playing of a group of channels by arbitrary tag.  <br /></td></tr>
<tr class="separator:aa5b6ac6a764dffe3005ea16341d9d044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c6066d45d6376b1c570fdc83622cc2" id="r_a90c6066d45d6376b1c570fdc83622cc2"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90c6066d45d6376b1c570fdc83622cc2">Mix_Paused</a> (int channel)</td></tr>
<tr class="memdesc:a90c6066d45d6376b1c570fdc83622cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether a particular channel is paused.  <br /></td></tr>
<tr class="separator:a90c6066d45d6376b1c570fdc83622cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe25a71474eae91d3ad725eb4ad8ed39" id="r_abe25a71474eae91d3ad725eb4ad8ed39"><td class="memItemLeft" align="right" valign="top">DECLSPEC void SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe25a71474eae91d3ad725eb4ad8ed39">Mix_PauseMusic</a> (void)</td></tr>
<tr class="memdesc:abe25a71474eae91d3ad725eb4ad8ed39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause the music stream.  <br /></td></tr>
<tr class="separator:abe25a71474eae91d3ad725eb4ad8ed39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45edeb5e03075593c4567e197565979" id="r_aa45edeb5e03075593c4567e197565979"><td class="memItemLeft" align="right" valign="top">DECLSPEC void SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa45edeb5e03075593c4567e197565979">Mix_ResumeMusic</a> (void)</td></tr>
<tr class="memdesc:aa45edeb5e03075593c4567e197565979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume the music stream.  <br /></td></tr>
<tr class="separator:aa45edeb5e03075593c4567e197565979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f8498924c913883808b0a3ac7f4ebc" id="r_a24f8498924c913883808b0a3ac7f4ebc"><td class="memItemLeft" align="right" valign="top">DECLSPEC void SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24f8498924c913883808b0a3ac7f4ebc">Mix_RewindMusic</a> (void)</td></tr>
<tr class="memdesc:a24f8498924c913883808b0a3ac7f4ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewind the music stream.  <br /></td></tr>
<tr class="separator:a24f8498924c913883808b0a3ac7f4ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6366b72369e1217ed7f45d2c0d5acb1d" id="r_a6366b72369e1217ed7f45d2c0d5acb1d"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6366b72369e1217ed7f45d2c0d5acb1d">Mix_PausedMusic</a> (void)</td></tr>
<tr class="memdesc:a6366b72369e1217ed7f45d2c0d5acb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the music stream is paused.  <br /></td></tr>
<tr class="separator:a6366b72369e1217ed7f45d2c0d5acb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d1bde4893345068c002773061ed71c" id="r_af1d1bde4893345068c002773061ed71c"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1d1bde4893345068c002773061ed71c">Mix_ModMusicJumpToOrder</a> (int order)</td></tr>
<tr class="memdesc:af1d1bde4893345068c002773061ed71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jump to a given order in mod music.  <br /></td></tr>
<tr class="separator:af1d1bde4893345068c002773061ed71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312db16e22c5fd8788bb695841d30456" id="r_a312db16e22c5fd8788bb695841d30456"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a312db16e22c5fd8788bb695841d30456">Mix_StartTrack</a> (<a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *music, int track)</td></tr>
<tr class="memdesc:a312db16e22c5fd8788bb695841d30456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a track in music object.  <br /></td></tr>
<tr class="separator:a312db16e22c5fd8788bb695841d30456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db88b2c1c4a875876695bcc0cd6f0f9" id="r_a8db88b2c1c4a875876695bcc0cd6f0f9"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8db88b2c1c4a875876695bcc0cd6f0f9">Mix_GetNumTracks</a> (<a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *music)</td></tr>
<tr class="memdesc:a8db88b2c1c4a875876695bcc0cd6f0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of tracks in music object.  <br /></td></tr>
<tr class="separator:a8db88b2c1c4a875876695bcc0cd6f0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa5bcba7e8d583f576180af0ff5a732" id="r_adfa5bcba7e8d583f576180af0ff5a732"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfa5bcba7e8d583f576180af0ff5a732">Mix_SetMusicPosition</a> (double position)</td></tr>
<tr class="memdesc:adfa5bcba7e8d583f576180af0ff5a732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current position in the music stream, in seconds.  <br /></td></tr>
<tr class="separator:adfa5bcba7e8d583f576180af0ff5a732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb2ce798a35d9a661329128b40e4430" id="r_a6cb2ce798a35d9a661329128b40e4430"><td class="memItemLeft" align="right" valign="top">DECLSPEC double SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cb2ce798a35d9a661329128b40e4430">Mix_GetMusicPosition</a> (<a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *music)</td></tr>
<tr class="memdesc:a6cb2ce798a35d9a661329128b40e4430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time current position of music stream, in seconds.  <br /></td></tr>
<tr class="separator:a6cb2ce798a35d9a661329128b40e4430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53dfe4fdc126896dc79272f7f3a40350" id="r_a53dfe4fdc126896dc79272f7f3a40350"><td class="memItemLeft" align="right" valign="top">DECLSPEC double SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53dfe4fdc126896dc79272f7f3a40350">Mix_MusicDuration</a> (<a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *music)</td></tr>
<tr class="memdesc:a53dfe4fdc126896dc79272f7f3a40350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a music object's duration, in seconds.  <br /></td></tr>
<tr class="separator:a53dfe4fdc126896dc79272f7f3a40350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc569e50d4ae6a243feecde69425633f" id="r_abc569e50d4ae6a243feecde69425633f"><td class="memItemLeft" align="right" valign="top">DECLSPEC double SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc569e50d4ae6a243feecde69425633f">Mix_GetMusicLoopStartTime</a> (<a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *music)</td></tr>
<tr class="memdesc:abc569e50d4ae6a243feecde69425633f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the loop start time position of music stream, in seconds.  <br /></td></tr>
<tr class="separator:abc569e50d4ae6a243feecde69425633f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147b90403524bda784e13e92b167b9f3" id="r_a147b90403524bda784e13e92b167b9f3"><td class="memItemLeft" align="right" valign="top">DECLSPEC double SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a147b90403524bda784e13e92b167b9f3">Mix_GetMusicLoopEndTime</a> (<a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *music)</td></tr>
<tr class="memdesc:a147b90403524bda784e13e92b167b9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the loop end time position of music stream, in seconds.  <br /></td></tr>
<tr class="separator:a147b90403524bda784e13e92b167b9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3344603f591526435d11ef3a7352b900" id="r_a3344603f591526435d11ef3a7352b900"><td class="memItemLeft" align="right" valign="top">DECLSPEC double SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3344603f591526435d11ef3a7352b900">Mix_GetMusicLoopLengthTime</a> (<a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *music)</td></tr>
<tr class="memdesc:a3344603f591526435d11ef3a7352b900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the loop time length of music stream, in seconds.  <br /></td></tr>
<tr class="separator:a3344603f591526435d11ef3a7352b900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2762f72d43ec5332250311a9887a8998" id="r_a2762f72d43ec5332250311a9887a8998"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2762f72d43ec5332250311a9887a8998">Mix_Playing</a> (int channel)</td></tr>
<tr class="memdesc:a2762f72d43ec5332250311a9887a8998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the playing status of a specific channel.  <br /></td></tr>
<tr class="separator:a2762f72d43ec5332250311a9887a8998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa325c04b56dc4fb7909b5636a12a9f67" id="r_aa325c04b56dc4fb7909b5636a12a9f67"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa325c04b56dc4fb7909b5636a12a9f67">Mix_PlayingMusic</a> (void)</td></tr>
<tr class="memdesc:aa325c04b56dc4fb7909b5636a12a9f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the playing status of the music stream.  <br /></td></tr>
<tr class="separator:aa325c04b56dc4fb7909b5636a12a9f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ae6e530b2bda61f772c74e374e70af" id="r_a06ae6e530b2bda61f772c74e374e70af"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06ae6e530b2bda61f772c74e374e70af">Mix_SetMusicCMD</a> (const char *command)</td></tr>
<tr class="memdesc:a06ae6e530b2bda61f772c74e374e70af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run an external command as the music stream.  <br /></td></tr>
<tr class="separator:a06ae6e530b2bda61f772c74e374e70af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78d8fcc7feb777a2d3b1e94cb178fd1" id="r_af78d8fcc7feb777a2d3b1e94cb178fd1"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af78d8fcc7feb777a2d3b1e94cb178fd1">Mix_SetSynchroValue</a> (int value)</td></tr>
<tr class="memdesc:af78d8fcc7feb777a2d3b1e94cb178fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function does nothing, do not use.  <br /></td></tr>
<tr class="separator:af78d8fcc7feb777a2d3b1e94cb178fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa614da725f8c139b50af9d79c62d79e0" id="r_aa614da725f8c139b50af9d79c62d79e0"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa614da725f8c139b50af9d79c62d79e0">Mix_GetSynchroValue</a> (void)</td></tr>
<tr class="memdesc:aa614da725f8c139b50af9d79c62d79e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function does nothing, do not use.  <br /></td></tr>
<tr class="separator:aa614da725f8c139b50af9d79c62d79e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa503e9b83c9fbf14496d93947568de8f" id="r_aa503e9b83c9fbf14496d93947568de8f"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa503e9b83c9fbf14496d93947568de8f">Mix_SetSoundFonts</a> (const char *paths)</td></tr>
<tr class="memdesc:aa503e9b83c9fbf14496d93947568de8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SoundFonts paths to use by supported MIDI backends.  <br /></td></tr>
<tr class="separator:aa503e9b83c9fbf14496d93947568de8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72fa4f7aedbb2b881483e4b89f5a2a2" id="r_ae72fa4f7aedbb2b881483e4b89f5a2a2"><td class="memItemLeft" align="right" valign="top">DECLSPEC const char *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae72fa4f7aedbb2b881483e4b89f5a2a2">Mix_GetSoundFonts</a> (void)</td></tr>
<tr class="memdesc:ae72fa4f7aedbb2b881483e4b89f5a2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SoundFonts paths to use by supported MIDI backends.  <br /></td></tr>
<tr class="separator:ae72fa4f7aedbb2b881483e4b89f5a2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e313199aa4bf611d80888b13bf51513" id="r_a9e313199aa4bf611d80888b13bf51513"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e313199aa4bf611d80888b13bf51513">Mix_EachSoundFont</a> (int(SDLCALL *function)(const char *, void *), void *data)</td></tr>
<tr class="memdesc:a9e313199aa4bf611d80888b13bf51513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate SoundFonts paths to use by supported MIDI backends.  <br /></td></tr>
<tr class="separator:a9e313199aa4bf611d80888b13bf51513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9d1061909d9b80853034120735fd57" id="r_acd9d1061909d9b80853034120735fd57"><td class="memItemLeft" align="right" valign="top">DECLSPEC int SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd9d1061909d9b80853034120735fd57">Mix_SetTimidityCfg</a> (const char *path)</td></tr>
<tr class="memdesc:acd9d1061909d9b80853034120735fd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set full path of the Timidity config file.  <br /></td></tr>
<tr class="separator:acd9d1061909d9b80853034120735fd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1405ea91714d0163795f88e2b7903668" id="r_a1405ea91714d0163795f88e2b7903668"><td class="memItemLeft" align="right" valign="top">DECLSPEC const char *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1405ea91714d0163795f88e2b7903668">Mix_GetTimidityCfg</a> (void)</td></tr>
<tr class="memdesc:a1405ea91714d0163795f88e2b7903668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get full path of a previously-specified Timidity config file.  <br /></td></tr>
<tr class="separator:a1405ea91714d0163795f88e2b7903668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37bb7b694296e52f97d22822a2057b8" id="r_af37bb7b694296e52f97d22822a2057b8"><td class="memItemLeft" align="right" valign="top">DECLSPEC <a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af37bb7b694296e52f97d22822a2057b8">Mix_GetChunk</a> (int channel)</td></tr>
<tr class="memdesc:af37bb7b694296e52f97d22822a2057b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="struct_mix___chunk.html" title="The internal format for an audio chunk.">Mix_Chunk</a> currently associated with a mixer channel.  <br /></td></tr>
<tr class="separator:af37bb7b694296e52f97d22822a2057b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb071e94923956f4c3ca4d3998669e7" id="r_a2cb071e94923956f4c3ca4d3998669e7"><td class="memItemLeft" align="right" valign="top">DECLSPEC void SDLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cb071e94923956f4c3ca4d3998669e7">Mix_CloseAudio</a> (void)</td></tr>
<tr class="memdesc:a2cb071e94923956f4c3ca4d3998669e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the mixer, halting all playing audio.  <br /></td></tr>
<tr class="separator:a2cb071e94923956f4c3ca4d3998669e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for SDL_mixer library. </p>
<p>A simple library to play and mix sounds and musics </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a7de550fb0c03378ab55cdf42c6e2fec9" name="a7de550fb0c03378ab55cdf42c6e2fec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de550fb0c03378ab55cdf42c6e2fec9">&#9670;&#160;</a></span>MIX_CHANNEL_POST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIX_CHANNEL_POST&#160;&#160;&#160;(-2)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b4a8b188543964be1ab99d33685d921" name="a8b4a8b188543964be1ab99d33685d921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4a8b188543964be1ab99d33685d921">&#9670;&#160;</a></span>MIX_CHANNELS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIX_CHANNELS&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default mixer has 8 simultaneous mixing channels. </p>

</div>
</div>
<a id="a6f49c5f9ea94150e3d1983d0a9652c6c" name="a6f49c5f9ea94150e3d1983d0a9652c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f49c5f9ea94150e3d1983d0a9652c6c">&#9670;&#160;</a></span>Mix_ClearError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Mix_ClearError&#160;&#160;&#160;SDL_ClearError</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear last SDL_mixer error. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#afd4c97802c19ab195d806459b7b520f7" title="Report SDL_mixer errors.">Mix_SetError</a> </dd></dl>

</div>
</div>
<a id="a31f2fc8f7be9e34899f044a5beada806" name="a31f2fc8f7be9e34899f044a5beada806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f2fc8f7be9e34899f044a5beada806">&#9670;&#160;</a></span>MIX_DEFAULT_CHANNELS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIX_DEFAULT_CHANNELS&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e0213e86be75a3b5bd28158a03cdb73" name="a9e0213e86be75a3b5bd28158a03cdb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0213e86be75a3b5bd28158a03cdb73">&#9670;&#160;</a></span>MIX_DEFAULT_FORMAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIX_DEFAULT_FORMAT&#160;&#160;&#160;SDL_AUDIO_S16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a960c830f43ad3bd2b802f9fa35ff394f" name="a960c830f43ad3bd2b802f9fa35ff394f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960c830f43ad3bd2b802f9fa35ff394f">&#9670;&#160;</a></span>MIX_DEFAULT_FREQUENCY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIX_DEFAULT_FREQUENCY&#160;&#160;&#160;44100</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aabb013a480a63af25255d0fa90ea9ab8" name="aabb013a480a63af25255d0fa90ea9ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb013a480a63af25255d0fa90ea9ab8">&#9670;&#160;</a></span>MIX_EFFECTSMAXSPEED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIX_EFFECTSMAXSPEED&#160;&#160;&#160;&quot;MIX_EFFECTSMAXSPEED&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab29aa52963e2c1dd92888629c810c74f" name="ab29aa52963e2c1dd92888629c810c74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29aa52963e2c1dd92888629c810c74f">&#9670;&#160;</a></span>Mix_GetError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Mix_GetError&#160;&#160;&#160;SDL_GetError</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get last SDL_mixer error. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#afd4c97802c19ab195d806459b7b520f7" title="Report SDL_mixer errors.">Mix_SetError</a> </dd></dl>

</div>
</div>
<a id="a8a6a91becf98340310a774d66f18a775" name="a8a6a91becf98340310a774d66f18a775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6a91becf98340310a774d66f18a775">&#9670;&#160;</a></span>MIX_MAJOR_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIX_MAJOR_VERSION&#160;&#160;&#160;<a class="el" href="#a62af8116474da839221137996edf6a0e">SDL_MIXER_MAJOR_VERSION</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3ee7ce3c29e7fb4314edba1035c12b6" name="ac3ee7ce3c29e7fb4314edba1035c12b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ee7ce3c29e7fb4314edba1035c12b6">&#9670;&#160;</a></span>MIX_MAX_VOLUME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIX_MAX_VOLUME&#160;&#160;&#160;SDL_MIX_MAXVOLUME /* Volume of a chunk */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a429f2a252000359a6538de6abd719c5f" name="a429f2a252000359a6538de6abd719c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429f2a252000359a6538de6abd719c5f">&#9670;&#160;</a></span>MIX_MINOR_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIX_MINOR_VERSION&#160;&#160;&#160;<a class="el" href="#afea96d57d92108eb55ced2900adef6a5">SDL_MIXER_MINOR_VERSION</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9ee824416a5e227f17fb29bedc4455e" name="ae9ee824416a5e227f17fb29bedc4455e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ee824416a5e227f17fb29bedc4455e">&#9670;&#160;</a></span>Mix_OutOfMemory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Mix_OutOfMemory&#160;&#160;&#160;SDL_OutOfMemory</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set OutOfMemory error. </p>

</div>
</div>
<a id="a1975c52524c62a7b2b2ee3bb00a362af" name="a1975c52524c62a7b2b2ee3bb00a362af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1975c52524c62a7b2b2ee3bb00a362af">&#9670;&#160;</a></span>MIX_PATCHLEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIX_PATCHLEVEL&#160;&#160;&#160;<a class="el" href="#ac00d5ae84eedcd8c85e5128625af3ddb">SDL_MIXER_PATCHLEVEL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd4c97802c19ab195d806459b7b520f7" name="afd4c97802c19ab195d806459b7b520f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4c97802c19ab195d806459b7b520f7">&#9670;&#160;</a></span>Mix_SetError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Mix_SetError&#160;&#160;&#160;SDL_SetError</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report SDL_mixer errors. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab29aa52963e2c1dd92888629c810c74f" title="Get last SDL_mixer error.">Mix_GetError</a> </dd></dl>

</div>
</div>
<a id="a3d8b3f1ee2d6372045cb0b2738ee868b" name="a3d8b3f1ee2d6372045cb0b2738ee868b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8b3f1ee2d6372045cb0b2738ee868b">&#9670;&#160;</a></span>MIX_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIX_VERSION</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">X</span></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="#ad6f12d4cf70382836dc0129afe796365">SDL_MIXER_VERSION</a>(X)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62af8116474da839221137996edf6a0e" name="a62af8116474da839221137996edf6a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62af8116474da839221137996edf6a0e">&#9670;&#160;</a></span>SDL_MIXER_MAJOR_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_MIXER_MAJOR_VERSION&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Printable format: "%d.%d.%d", MAJOR, MINOR, PATCHLEVEL. </p>

</div>
</div>
<a id="afea96d57d92108eb55ced2900adef6a5" name="afea96d57d92108eb55ced2900adef6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea96d57d92108eb55ced2900adef6a5">&#9670;&#160;</a></span>SDL_MIXER_MINOR_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_MIXER_MINOR_VERSION&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac00d5ae84eedcd8c85e5128625af3ddb" name="ac00d5ae84eedcd8c85e5128625af3ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00d5ae84eedcd8c85e5128625af3ddb">&#9670;&#160;</a></span>SDL_MIXER_PATCHLEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_MIXER_PATCHLEVEL&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6f12d4cf70382836dc0129afe796365" name="ad6f12d4cf70382836dc0129afe796365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f12d4cf70382836dc0129afe796365">&#9670;&#160;</a></span>SDL_MIXER_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_MIXER_VERSION</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">X</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                   \</div>
<div class="line">    (X)-&gt;major = <a class="code hl_define" href="#a62af8116474da839221137996edf6a0e">SDL_MIXER_MAJOR_VERSION</a>;           \</div>
<div class="line">    (X)-&gt;minor = <a class="code hl_define" href="#afea96d57d92108eb55ced2900adef6a5">SDL_MIXER_MINOR_VERSION</a>;           \</div>
<div class="line">    (X)-&gt;patch = <a class="code hl_define" href="#ac00d5ae84eedcd8c85e5128625af3ddb">SDL_MIXER_PATCHLEVEL</a>;              \</div>
<div class="line">}</div>
<div class="ttc" id="a_s_d_l__mixer_8h_html_a62af8116474da839221137996edf6a0e"><div class="ttname"><a href="#a62af8116474da839221137996edf6a0e">SDL_MIXER_MAJOR_VERSION</a></div><div class="ttdeci">#define SDL_MIXER_MAJOR_VERSION</div><div class="ttdoc">Printable format: &quot;%d.%d.%d&quot;, MAJOR, MINOR, PATCHLEVEL.</div><div class="ttdef"><b>Definition</b> SDL_mixer.h:43</div></div>
<div class="ttc" id="a_s_d_l__mixer_8h_html_ac00d5ae84eedcd8c85e5128625af3ddb"><div class="ttname"><a href="#ac00d5ae84eedcd8c85e5128625af3ddb">SDL_MIXER_PATCHLEVEL</a></div><div class="ttdeci">#define SDL_MIXER_PATCHLEVEL</div><div class="ttdef"><b>Definition</b> SDL_mixer.h:45</div></div>
<div class="ttc" id="a_s_d_l__mixer_8h_html_afea96d57d92108eb55ced2900adef6a5"><div class="ttname"><a href="#afea96d57d92108eb55ced2900adef6a5">SDL_MIXER_MINOR_VERSION</a></div><div class="ttdeci">#define SDL_MIXER_MINOR_VERSION</div><div class="ttdef"><b>Definition</b> SDL_mixer.h:44</div></div>
</div><!-- fragment -->
<p>This macro can be used to fill a version structure with the compile-time version of the SDL_mixer library. </p>

</div>
</div>
<a id="afd9e10cfedac69c7ef050c98e121461c" name="afd9e10cfedac69c7ef050c98e121461c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9e10cfedac69c7ef050c98e121461c">&#9670;&#160;</a></span>SDL_MIXER_VERSION_ATLEAST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDL_MIXER_VERSION_ATLEAST</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">X, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">Y, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">Z</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ((<a class="code hl_define" href="#a62af8116474da839221137996edf6a0e">SDL_MIXER_MAJOR_VERSION</a> &gt;= X) &amp;&amp; \</div>
<div class="line">     (<a class="code hl_define" href="#a62af8116474da839221137996edf6a0e">SDL_MIXER_MAJOR_VERSION</a> &gt; X || <a class="code hl_define" href="#afea96d57d92108eb55ced2900adef6a5">SDL_MIXER_MINOR_VERSION</a> &gt;= Y) &amp;&amp; \</div>
<div class="line">     (<a class="code hl_define" href="#a62af8116474da839221137996edf6a0e">SDL_MIXER_MAJOR_VERSION</a> &gt; X || <a class="code hl_define" href="#afea96d57d92108eb55ced2900adef6a5">SDL_MIXER_MINOR_VERSION</a> &gt; Y || <a class="code hl_define" href="#ac00d5ae84eedcd8c85e5128625af3ddb">SDL_MIXER_PATCHLEVEL</a> &gt;= Z))</div>
</div><!-- fragment -->
<p>This macro will evaluate to true if compiled with SDL_mixer at least X.Y.Z. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a0ec5298fec4179ed9c265e68f007755e" name="a0ec5298fec4179ed9c265e68f007755e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec5298fec4179ed9c265e68f007755e">&#9670;&#160;</a></span>Mix_Chunk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct Mix_Chunk Mix_Chunk</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The internal format for an audio chunk. </p>

</div>
</div>
<a id="ac568739ba54c90964224a2b6365f61c7" name="ac568739ba54c90964224a2b6365f61c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac568739ba54c90964224a2b6365f61c7">&#9670;&#160;</a></span>Mix_EffectDone_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(SDLCALL * Mix_EffectDone_t) (int chan, void *udata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a callback that signifies that a channel has finished all its loops and has completed playback. </p>
<p>This gets called if the buffer plays out normally, or if you call <a class="el" href="#a369f1cc25e69d0dc2a6f652109de9683" title="Halt playing of a particular channel.">Mix_HaltChannel()</a>, implicitly stop a channel via <a class="el" href="#a3bb24eade448b0c5515f9d402d935924" title="Dynamically change the number of channels managed by the mixer.">Mix_AllocateChannels()</a>, or unregister a callback while it's still playing.</p>
<p>DO NOT EVER call SDL_LockAudio() from your callback function! </p>

</div>
</div>
<a id="aed80ffef737d37eefc7354e0ebff8c1b" name="aed80ffef737d37eefc7354e0ebff8c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed80ffef737d37eefc7354e0ebff8c1b">&#9670;&#160;</a></span>Mix_EffectFunc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(SDLCALL * Mix_EffectFunc_t) (int chan, void *stream, int len, void *udata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the format of a special effect callback: </p>
<p>myeffect(int chan, void *stream, int len, void *udata);</p>
<p>(chan) is the channel number that your effect is affecting. (stream) is the buffer of data to work upon. (len) is the size of (stream), and (udata) is a user-defined bit of data, which you pass as the last arg of <a class="el" href="#aa3843504b9dfb94b22d4f74721adebf8" title="Register a special effect function.">Mix_RegisterEffect()</a>, and is passed back unmolested to your callback. Your effect changes the contents of (stream) based on whatever parameters are significant, or just leaves it be, if you prefer. You can do whatever you like to the buffer, though, and it will continue in its changed state down the mixing pipeline, through any other effect functions, then finally to be mixed with the rest of the channels and music for the final output stream.</p>
<p>DO NOT EVER call SDL_LockAudio() from your callback function! </p>

</div>
</div>
<a id="acb9ac0ecc8a273861e44292905c24487" name="acb9ac0ecc8a273861e44292905c24487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9ac0ecc8a273861e44292905c24487">&#9670;&#160;</a></span>Mix_Fading</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#a362f2bccb8d01c337b0c6a934edd456c">Mix_Fading</a> <a class="el" href="#a362f2bccb8d01c337b0c6a934edd456c">Mix_Fading</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The different fading types supported. </p>

</div>
</div>
<a id="a2ad23aad3b0e340fbc73a9eef0b4228c" name="a2ad23aad3b0e340fbc73a9eef0b4228c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad23aad3b0e340fbc73a9eef0b4228c">&#9670;&#160;</a></span>MIX_InitFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#a3de2cd65e9533014d1bba145f6f2d36d">MIX_InitFlags</a> <a class="el" href="#a3de2cd65e9533014d1bba145f6f2d36d">MIX_InitFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization flags. </p>

</div>
</div>
<a id="a1d58ae8fa29e1c03df23baeffb32b14c" name="a1d58ae8fa29e1c03df23baeffb32b14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d58ae8fa29e1c03df23baeffb32b14c">&#9670;&#160;</a></span>Mix_Music</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _Mix_Music <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The internal format for a music chunk interpreted via codecs. </p>

</div>
</div>
<a id="af33487cba51a51972c7268f008039e30" name="af33487cba51a51972c7268f008039e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33487cba51a51972c7268f008039e30">&#9670;&#160;</a></span>Mix_MusicType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46">Mix_MusicType</a> <a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46">Mix_MusicType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These are types of music files (not libraries used to load them) </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a362f2bccb8d01c337b0c6a934edd456c" name="a362f2bccb8d01c337b0c6a934edd456c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362f2bccb8d01c337b0c6a934edd456c">&#9670;&#160;</a></span>Mix_Fading</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a362f2bccb8d01c337b0c6a934edd456c">Mix_Fading</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The different fading types supported. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a362f2bccb8d01c337b0c6a934edd456ca81b8ccddd079a5f13aba7b21d1e475a4" name="a362f2bccb8d01c337b0c6a934edd456ca81b8ccddd079a5f13aba7b21d1e475a4"></a>MIX_NO_FADING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a362f2bccb8d01c337b0c6a934edd456caa2d71aa2141ab0f2ff514f2c5d49a70c" name="a362f2bccb8d01c337b0c6a934edd456caa2d71aa2141ab0f2ff514f2c5d49a70c"></a>MIX_FADING_OUT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a362f2bccb8d01c337b0c6a934edd456cacac9dbc0a92b5116934dd4036e9e25ef" name="a362f2bccb8d01c337b0c6a934edd456cacac9dbc0a92b5116934dd4036e9e25ef"></a>MIX_FADING_IN&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a3de2cd65e9533014d1bba145f6f2d36d" name="a3de2cd65e9533014d1bba145f6f2d36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de2cd65e9533014d1bba145f6f2d36d">&#9670;&#160;</a></span>MIX_InitFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a3de2cd65e9533014d1bba145f6f2d36d">MIX_InitFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3de2cd65e9533014d1bba145f6f2d36dad2c4a750250632be803a8c4520d4c486" name="a3de2cd65e9533014d1bba145f6f2d36dad2c4a750250632be803a8c4520d4c486"></a>MIX_INIT_FLAC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3de2cd65e9533014d1bba145f6f2d36dae3af2cbd16a150ae341f4286c0a5e394" name="a3de2cd65e9533014d1bba145f6f2d36dae3af2cbd16a150ae341f4286c0a5e394"></a>MIX_INIT_MOD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3de2cd65e9533014d1bba145f6f2d36daf439578078fa1f57ec9a09efe38ef24f" name="a3de2cd65e9533014d1bba145f6f2d36daf439578078fa1f57ec9a09efe38ef24f"></a>MIX_INIT_MP3&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3de2cd65e9533014d1bba145f6f2d36da2256680914b5648ffc8e54ab0bf4e00c" name="a3de2cd65e9533014d1bba145f6f2d36da2256680914b5648ffc8e54ab0bf4e00c"></a>MIX_INIT_OGG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3de2cd65e9533014d1bba145f6f2d36da70fbe004ddc741792efd399c7ce067a2" name="a3de2cd65e9533014d1bba145f6f2d36da70fbe004ddc741792efd399c7ce067a2"></a>MIX_INIT_MID&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3de2cd65e9533014d1bba145f6f2d36dad4ef1e2599786b1d769766e6baa21d10" name="a3de2cd65e9533014d1bba145f6f2d36dad4ef1e2599786b1d769766e6baa21d10"></a>MIX_INIT_OPUS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3de2cd65e9533014d1bba145f6f2d36da1aecb8b7037e750e8a38486f1f39a346" name="a3de2cd65e9533014d1bba145f6f2d36da1aecb8b7037e750e8a38486f1f39a346"></a>MIX_INIT_WAVPACK&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a3deb8c84c2e0a1bb970cd496d9e46f46" name="a3deb8c84c2e0a1bb970cd496d9e46f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3deb8c84c2e0a1bb970cd496d9e46f46">&#9670;&#160;</a></span>Mix_MusicType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46">Mix_MusicType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These are types of music files (not libraries used to load them) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3deb8c84c2e0a1bb970cd496d9e46f46ad6c456444e9634514a07c31947bf51a7" name="a3deb8c84c2e0a1bb970cd496d9e46f46ad6c456444e9634514a07c31947bf51a7"></a>MUS_NONE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3deb8c84c2e0a1bb970cd496d9e46f46a218a2952d564324cfc6fe78e4c598c39" name="a3deb8c84c2e0a1bb970cd496d9e46f46a218a2952d564324cfc6fe78e4c598c39"></a>MUS_CMD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3deb8c84c2e0a1bb970cd496d9e46f46ad2905fd8e5ac57321dea83f0afc8d7b6" name="a3deb8c84c2e0a1bb970cd496d9e46f46ad2905fd8e5ac57321dea83f0afc8d7b6"></a>MUS_WAV&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3deb8c84c2e0a1bb970cd496d9e46f46aa1cd53bdbec42e838e5da8863741eae1" name="a3deb8c84c2e0a1bb970cd496d9e46f46aa1cd53bdbec42e838e5da8863741eae1"></a>MUS_MOD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3deb8c84c2e0a1bb970cd496d9e46f46ac69784a48a28e2dafec3ef307ed0bf2b" name="a3deb8c84c2e0a1bb970cd496d9e46f46ac69784a48a28e2dafec3ef307ed0bf2b"></a>MUS_MID&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3deb8c84c2e0a1bb970cd496d9e46f46a9a80ce658507a45c33dd78c3a63deec2" name="a3deb8c84c2e0a1bb970cd496d9e46f46a9a80ce658507a45c33dd78c3a63deec2"></a>MUS_OGG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3deb8c84c2e0a1bb970cd496d9e46f46a7edd0d75c1734063c604df8a11ef8a7a" name="a3deb8c84c2e0a1bb970cd496d9e46f46a7edd0d75c1734063c604df8a11ef8a7a"></a>MUS_MP3&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3deb8c84c2e0a1bb970cd496d9e46f46a09f1e7e27da259c0ecd100fd3a216239" name="a3deb8c84c2e0a1bb970cd496d9e46f46a09f1e7e27da259c0ecd100fd3a216239"></a>MUS_MP3_MAD_UNUSED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3deb8c84c2e0a1bb970cd496d9e46f46ac264a114cab6e312b12d8a88e14b8293" name="a3deb8c84c2e0a1bb970cd496d9e46f46ac264a114cab6e312b12d8a88e14b8293"></a>MUS_FLAC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3deb8c84c2e0a1bb970cd496d9e46f46a12fd85839605e40ff543b607da27a45e" name="a3deb8c84c2e0a1bb970cd496d9e46f46a12fd85839605e40ff543b607da27a45e"></a>MUS_MODPLUG_UNUSED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3deb8c84c2e0a1bb970cd496d9e46f46ae48bb4a7408f13511559e18ac68da401" name="a3deb8c84c2e0a1bb970cd496d9e46f46ae48bb4a7408f13511559e18ac68da401"></a>MUS_OPUS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3deb8c84c2e0a1bb970cd496d9e46f46adb6c0b4f8f046dc130c58236968e5720" name="a3deb8c84c2e0a1bb970cd496d9e46f46adb6c0b4f8f046dc130c58236968e5720"></a>MUS_WAVPACK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3deb8c84c2e0a1bb970cd496d9e46f46a87e8a8b5695c2c352dc939cc92d80da6" name="a3deb8c84c2e0a1bb970cd496d9e46f46a87e8a8b5695c2c352dc939cc92d80da6"></a>MUS_GME&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3bb24eade448b0c5515f9d402d935924" name="a3bb24eade448b0c5515f9d402d935924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb24eade448b0c5515f9d402d935924">&#9670;&#160;</a></span>Mix_AllocateChannels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_AllocateChannels </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numchans</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamically change the number of channels managed by the mixer. </p>
<p>SDL_mixer deals with "channels," which is not the same thing as the mono/stereo channels; they might be better described as "tracks," as each one corresponds to a separate source of audio data. Three different WAV files playing at the same time would be three separate SDL_mixer channels, for example.</p>
<p>An app needs as many channels as it has audio data it wants to play simultaneously, mixing them into a single stream to send to the audio device.</p>
<p>SDL_mixer allocates <code>MIX_CHANNELS</code> (currently 8) channels when you open an audio device, which may be more than an app needs, but if the app needs more or wants less, this function can change it.</p>
<p>If decreasing the number of channels, any upper channels currently playing are stopped. This will deregister all effects on those channels and call any callback specified by <a class="el" href="#a8bb79c6f792464428d51b6aba1088b77" title="Set a callback that runs when a channel has finished playing.">Mix_ChannelFinished()</a> for each removed channel.</p>
<p>If <code>numchans</code> is less than zero, this will return the current number of channels without changing anything.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numchans</td><td>the new number of channels, or &lt; 0 to query current channel count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new number of allocated channels.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a8bb79c6f792464428d51b6aba1088b77" name="a8bb79c6f792464428d51b6aba1088b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb79c6f792464428d51b6aba1088b77">&#9670;&#160;</a></span>Mix_ChannelFinished()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC void SDLCALL Mix_ChannelFinished </td>
          <td>(</td>
          <td class="paramtype">void(SDLCALL *channel_finished)(int channel)</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a callback that runs when a channel has finished playing. </p>
<p>The callback may be called from the mixer's audio callback or it could be called as a result of <a class="el" href="#a369f1cc25e69d0dc2a6f652109de9683" title="Halt playing of a particular channel.">Mix_HaltChannel()</a>, etc.</p>
<p>The callback has a single parameter, <code>channel</code>, which says what mixer channel has just stopped.</p>
<p>Do not call SDL_LockAudio() from this callback; you will either be inside the audio callback, or SDL_mixer will explicitly lock the audio before calling your callback.</p>
<p>A NULL pointer will disable the callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_finished</td><td>the callback function to become the new notification mechanism.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a2cb071e94923956f4c3ca4d3998669e7" name="a2cb071e94923956f4c3ca4d3998669e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb071e94923956f4c3ca4d3998669e7">&#9670;&#160;</a></span>Mix_CloseAudio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC void SDLCALL Mix_CloseAudio </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the mixer, halting all playing audio. </p>
<p>Any halted channels will have any currently-registered effects deregistered, and will call any callback specified by <a class="el" href="#a8bb79c6f792464428d51b6aba1088b77" title="Set a callback that runs when a channel has finished playing.">Mix_ChannelFinished()</a> before this function returns.</p>
<p>Any halted music will call any callback specified by <a class="el" href="#ab715ac2972aed61a2eaff4f980beb594" title="Set a callback that runs when a music object has stopped playing.">Mix_HookMusicFinished()</a> before this function returns.</p>
<p>Do not start any new audio playing during callbacks in this function.</p>
<p>This will close the audio device. Attempting to play new audio after this function returns will fail, until another successful call to <a class="el" href="#a23afb407fa3a9766f21d07ea43bee1cd" title="Open an audio device for playback.">Mix_OpenAudio()</a>.</p>
<p>Note that (unlike Mix_OpenAudio optionally calling SDL_Init(SDL_INIT_AUDIO) on the app's behalf), this will <em>not</em> deinitialize the SDL audio subsystem in any case. At some point after calling this function and <a class="el" href="#a136e5586b53fe0e3e752e2174bd7bb70" title="Deinitialize SDL_mixer.">Mix_Quit()</a>, some part of the application should be responsible for calling SDL_Quit() to deinitialize all of SDL, including its audio subsystem.</p>
<p>This function should be the last thing you call in SDL_mixer before <a class="el" href="#a136e5586b53fe0e3e752e2174bd7bb70" title="Deinitialize SDL_mixer.">Mix_Quit()</a>. However, the following notes apply if you don't follow this advice:</p>
<p>Note that this will not free any loaded chunks or music; you should dispose of those resources separately. It is probably poor form to dispose of them <em>after</em> this function, but it is safe to call <a class="el" href="#abf7ae3433476bb4f66acedc6098e5b2d" title="Free an audio chunk.">Mix_FreeChunk()</a> and <a class="el" href="#ac2e103808706941aab379d601a46327b" title="Free a music object.">Mix_FreeMusic()</a> after closing the device.</p>
<p>Note that any chunks or music you don't free may or may not work if you call Mix_OpenAudio again, as the audio device may be in a new format and the existing chunks will not be converted to match.</p>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a136e5586b53fe0e3e752e2174bd7bb70" title="Deinitialize SDL_mixer.">Mix_Quit</a> </dd></dl>

</div>
</div>
<a id="a9e313199aa4bf611d80888b13bf51513" name="a9e313199aa4bf611d80888b13bf51513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e313199aa4bf611d80888b13bf51513">&#9670;&#160;</a></span>Mix_EachSoundFont()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_EachSoundFont </td>
          <td>(</td>
          <td class="paramtype">int(SDLCALL *function)(const char *, void *)</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate SoundFonts paths to use by supported MIDI backends. </p>
<p>This function will take the string reported by <a class="el" href="#ae72fa4f7aedbb2b881483e4b89f5a2a2" title="Get SoundFonts paths to use by supported MIDI backends.">Mix_GetSoundFonts()</a>, split it up into separate paths, as delimited by semicolons in the string, and call a callback function for each separate path.</p>
<p>If there are no paths available, this returns 0 without calling the callback at all.</p>
<p>If the callback returns non-zero, this function stops iterating and returns non-zero. If the callback returns 0, this function will continue iterating, calling the callback again for further paths. If the callback never returns 1, this function returns 0, so this can be used to decide if an available soundfont is acceptable for use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>the callback function to call once per path. </td></tr>
    <tr><td class="paramname">data</td><td>a pointer to pass to the callback for its own personal use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if callback ever returned non-zero, 0 on error or the callback never returned non-zero.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae72fa4f7aedbb2b881483e4b89f5a2a2" title="Get SoundFonts paths to use by supported MIDI backends.">Mix_GetSoundFonts</a> </dd></dl>

</div>
</div>
<a id="a5ca9a903a8f102404d9f588b83fec7fe" name="a5ca9a903a8f102404d9f588b83fec7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca9a903a8f102404d9f588b83fec7fe">&#9670;&#160;</a></span>Mix_ExpireChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_ExpireChannel </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ticks</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the expiration delay for a particular channel. </p>
<p>The channel will halt after the 'ticks' milliseconds have elapsed, or remove the expiration if 'ticks' is -1.</p>
<p>This overrides the value passed to the fourth parameter of <a class="el" href="#a9e7e5bb8d3dbd3539eb3d032589fc624" title="Play an audio chunk on a specific channel for a maximum time.">Mix_PlayChannelTimed()</a>.</p>
<p>Specifying a channel of -1 will set an expiration for <em>all</em> channels.</p>
<p>Any halted channels will have any currently-registered effects deregistered, and will call any callback specified by <a class="el" href="#a8bb79c6f792464428d51b6aba1088b77" title="Set a callback that runs when a channel has finished playing.">Mix_ChannelFinished()</a> once the halt occurs.</p>
<p>Note that this function does not block for the number of ticks requested; it just schedules the chunk to expire and notes the time for the mixer to manage later, and returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to change the expiration time on. </td></tr>
    <tr><td class="paramname">ticks</td><td>number of milliseconds from now to let channel play before halting, -1 to not halt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of channels that changed expirations.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="ab7e6b40eb77070b3e74f4f7c1669acbd" name="ab7e6b40eb77070b3e74f4f7c1669acbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e6b40eb77070b3e74f4f7c1669acbd">&#9670;&#160;</a></span>Mix_FadeInChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_FadeInChannel </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *</td>          <td class="paramname"><span class="paramname"><em>chunk</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>loops</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ms</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Play an audio chunk on a specific channel, fading in the audio. </p>
<p>This will start the new sound playing, much like <a class="el" href="#af9f0143230493220f052f50e1cabc070" title="Play an audio chunk on a specific channel.">Mix_PlayChannel()</a> will, but will start the sound playing at silence and fade in to its normal volume over the specified number of milliseconds.</p>
<p>If the specified channel is -1, play on the first free channel (and return -1 without playing anything new if no free channel was available).</p>
<p>If a specific channel was requested, and there is a chunk already playing there, that chunk will be halted and the new chunk will take its place.</p>
<p>If <code>loops</code> is greater than zero, loop the sound that many times. If <code>loops</code> is -1, loop "infinitely" (~65000 times).</p>
<p>A fading channel will change it's volume progressively, as if <a class="el" href="#a41d2418a357057d2aabad338476e1b9a" title="Set the volume for a specific channel.">Mix_Volume()</a> was called on it (which is to say: you probably shouldn't call <a class="el" href="#a41d2418a357057d2aabad338476e1b9a" title="Set the volume for a specific channel.">Mix_Volume()</a> on a fading channel).</p>
<p>Note that before SDL_mixer 3.0.0, this function was a macro that called <a class="el" href="#a1fb54ff92263b255ec013cdd1ee21d9e" title="Play an audio chunk on a specific channel, fading in the audio, for a maximum time.">Mix_FadeInChannelTimed()</a> with a fourth parameter ("ticks") of -1. This function still does the same thing, but promotes it to a proper API function. Older binaries linked against a newer SDL_mixer will still call Mix_FadeInChannelTimed directly, as they are using the macro, which was available since the dawn of time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel on which to play the new chunk, or -1 to find any available. </td></tr>
    <tr><td class="paramname">chunk</td><td>the new chunk to play. </td></tr>
    <tr><td class="paramname">loops</td><td>the number of times the chunk should loop, -1 to loop (not actually) infinitely. </td></tr>
    <tr><td class="paramname">ms</td><td>the number of milliseconds to spend fading in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>which channel was used to play the sound, or -1 if sound could not be played.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0 </dd></dl>

</div>
</div>
<a id="a1fb54ff92263b255ec013cdd1ee21d9e" name="a1fb54ff92263b255ec013cdd1ee21d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb54ff92263b255ec013cdd1ee21d9e">&#9670;&#160;</a></span>Mix_FadeInChannelTimed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_FadeInChannelTimed </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *</td>          <td class="paramname"><span class="paramname"><em>chunk</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>loops</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ticks</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Play an audio chunk on a specific channel, fading in the audio, for a maximum time. </p>
<p>This will start the new sound playing, much like <a class="el" href="#af9f0143230493220f052f50e1cabc070" title="Play an audio chunk on a specific channel.">Mix_PlayChannel()</a> will, but will start the sound playing at silence and fade in to its normal volume over the specified number of milliseconds.</p>
<p>If the specified channel is -1, play on the first free channel (and return -1 without playing anything new if no free channel was available).</p>
<p>If a specific channel was requested, and there is a chunk already playing there, that chunk will be halted and the new chunk will take its place.</p>
<p>If <code>loops</code> is greater than zero, loop the sound that many times. If <code>loops</code> is -1, loop "infinitely" (~65000 times).</p>
<p><code>ticks</code> specifies the maximum number of milliseconds to play this chunk before halting it. If you want the chunk to play until all data has been mixed, specify -1.</p>
<p>Note that this function does not block for the number of ticks requested; it just schedules the chunk to play and notes the maximum for the mixer to manage later, and returns immediately.</p>
<p>A fading channel will change it's volume progressively, as if <a class="el" href="#a41d2418a357057d2aabad338476e1b9a" title="Set the volume for a specific channel.">Mix_Volume()</a> was called on it (which is to say: you probably shouldn't call <a class="el" href="#a41d2418a357057d2aabad338476e1b9a" title="Set the volume for a specific channel.">Mix_Volume()</a> on a fading channel).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel on which to play the new chunk, or -1 to find any available. </td></tr>
    <tr><td class="paramname">chunk</td><td>the new chunk to play. </td></tr>
    <tr><td class="paramname">loops</td><td>the number of times the chunk should loop, -1 to loop (not actually) infinitely. </td></tr>
    <tr><td class="paramname">ms</td><td>the number of milliseconds to spend fading in. </td></tr>
    <tr><td class="paramname">ticks</td><td>the maximum number of milliseconds of this chunk to mix for playback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>which channel was used to play the sound, or -1 if sound could not be played.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a2400bb4d58a5bce5e1c734f2b09bface" name="a2400bb4d58a5bce5e1c734f2b09bface"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2400bb4d58a5bce5e1c734f2b09bface">&#9670;&#160;</a></span>Mix_FadeInMusic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_FadeInMusic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *</td>          <td class="paramname"><span class="paramname"><em>music</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>loops</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ms</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Play a new music object, fading in the audio. </p>
<p>This will start the new music playing, much like <a class="el" href="#a215ea5402d7da6d73a53b408d33b06b3" title="Play a new music object.">Mix_PlayMusic()</a> will, but will start the music playing at silence and fade in to its normal volume over the specified number of milliseconds.</p>
<p>If there is already music playing, that music will be halted and the new music object will take its place.</p>
<p>If <code>loops</code> is greater than zero, loop the music that many times. If <code>loops</code> is -1, loop "infinitely" (~65000 times).</p>
<p>Fading music will change it's volume progressively, as if <a class="el" href="#ab926fc25eab93de464ac7029e2125003" title="Set the volume for the music channel.">Mix_VolumeMusic()</a> was called on it (which is to say: you probably shouldn't call <a class="el" href="#ab926fc25eab93de464ac7029e2125003" title="Set the volume for the music channel.">Mix_VolumeMusic()</a> on fading music).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music</td><td>the new music object to play. </td></tr>
    <tr><td class="paramname">loops</td><td>the number of times the chunk should loop, -1 to loop (not actually) infinitely. </td></tr>
    <tr><td class="paramname">ms</td><td>the number of milliseconds to spend fading in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on success, -1 on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a636e248dd7cd411c3edcebd2c74db71e" name="a636e248dd7cd411c3edcebd2c74db71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636e248dd7cd411c3edcebd2c74db71e">&#9670;&#160;</a></span>Mix_FadeInMusicPos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_FadeInMusicPos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *</td>          <td class="paramname"><span class="paramname"><em>music</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>loops</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>position</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Play a new music object, fading in the audio, from a starting position. </p>
<p>This will start the new music playing, much like <a class="el" href="#a215ea5402d7da6d73a53b408d33b06b3" title="Play a new music object.">Mix_PlayMusic()</a> will, but will start the music playing at silence and fade in to its normal volume over the specified number of milliseconds.</p>
<p>If there is already music playing, that music will be halted and the new music object will take its place.</p>
<p>If <code>loops</code> is greater than zero, loop the music that many times. If <code>loops</code> is -1, loop "infinitely" (~65000 times).</p>
<p>Fading music will change it's volume progressively, as if <a class="el" href="#ab926fc25eab93de464ac7029e2125003" title="Set the volume for the music channel.">Mix_VolumeMusic()</a> was called on it (which is to say: you probably shouldn't call <a class="el" href="#ab926fc25eab93de464ac7029e2125003" title="Set the volume for the music channel.">Mix_VolumeMusic()</a> on fading music).</p>
<p>This function allows the caller to start the music playback past the beginning of its audio data. You may specify a start position, in seconds, and the playback and fade-in will start there instead of with the first samples of the music.</p>
<p>An app can specify a <code>position</code> of 0.0 to start at the beginning of the music (or just call <a class="el" href="#a2400bb4d58a5bce5e1c734f2b09bface" title="Play a new music object, fading in the audio.">Mix_FadeInMusic()</a> instead).</p>
<p>To convert from milliseconds, divide by 1000.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music</td><td>the new music object to play. </td></tr>
    <tr><td class="paramname">loops</td><td>the number of times the chunk should loop, -1 to loop (not actually) infinitely. </td></tr>
    <tr><td class="paramname">ms</td><td>the number of milliseconds to spend fading in. </td></tr>
    <tr><td class="paramname">position</td><td>the start position within the music, in seconds, where playback should start. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on success, -1 on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="ace4743866ba2f907858de7fa2ef6108f" name="ace4743866ba2f907858de7fa2ef6108f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4743866ba2f907858de7fa2ef6108f">&#9670;&#160;</a></span>Mix_FadeOutChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_FadeOutChannel </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>which</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ms</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Halt a channel after fading it out for a specified time. </p>
<p>This will begin a channel fading from its current volume to silence over <code>ms</code> milliseconds. After that time, the channel is halted.</p>
<p>Any halted channels will have any currently-registered effects deregistered, and will call any callback specified by <a class="el" href="#a8bb79c6f792464428d51b6aba1088b77" title="Set a callback that runs when a channel has finished playing.">Mix_ChannelFinished()</a> once the halt occurs.</p>
<p>A fading channel will change it's volume progressively, as if <a class="el" href="#a41d2418a357057d2aabad338476e1b9a" title="Set the volume for a specific channel.">Mix_Volume()</a> was called on it (which is to say: you probably shouldn't call <a class="el" href="#a41d2418a357057d2aabad338476e1b9a" title="Set the volume for a specific channel.">Mix_Volume()</a> on a fading channel).</p>
<p>Note that this function does not block for the number of milliseconds requested; it just schedules the chunk to fade and notes the time for the mixer to manage later, and returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>the channel to fade out. </td></tr>
    <tr><td class="paramname">ms</td><td>number of milliseconds to fade before halting the channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of channels scheduled to fade.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="ab62361006702546e9d66021c0c9f5a5b" name="ab62361006702546e9d66021c0c9f5a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62361006702546e9d66021c0c9f5a5b">&#9670;&#160;</a></span>Mix_FadeOutGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_FadeOutGroup </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tag</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ms</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Halt a playing group of channels by arbitrary tag, after fading them out for a specified time. </p>
<p>This will begin fading a group of channels with a specific tag from their current volumes to silence over <code>ms</code> milliseconds. After that time, those channels are halted.</p>
<p>A tag is an arbitrary number that can be assigned to several mixer channels, to form groups of channels.</p>
<p>The default tag for a channel is -1.</p>
<p>Any halted channels will have any currently-registered effects deregistered, and will call any callback specified by <a class="el" href="#a8bb79c6f792464428d51b6aba1088b77" title="Set a callback that runs when a channel has finished playing.">Mix_ChannelFinished()</a> once the halt occurs.</p>
<p>A fading channel will change it's volume progressively, as if <a class="el" href="#a41d2418a357057d2aabad338476e1b9a" title="Set the volume for a specific channel.">Mix_Volume()</a> was called on it (which is to say: you probably shouldn't call <a class="el" href="#a41d2418a357057d2aabad338476e1b9a" title="Set the volume for a specific channel.">Mix_Volume()</a> on a fading channel).</p>
<p>Note that this function does not block for the number of milliseconds requested; it just schedules the group to fade and notes the time for the mixer to manage later, and returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>an arbitrary value, assigned to channels, to search for. </td></tr>
    <tr><td class="paramname">ms</td><td>number of milliseconds to fade before halting the group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of channels that were scheduled for fading.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="aff8cc2e99284bf7268b1ee62b86b5367" name="aff8cc2e99284bf7268b1ee62b86b5367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8cc2e99284bf7268b1ee62b86b5367">&#9670;&#160;</a></span>Mix_FadeOutMusic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_FadeOutMusic </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ms</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Halt the music stream after fading it out for a specified time. </p>
<p>This will begin the music fading from its current volume to silence over <code>ms</code> milliseconds. After that time, the music is halted.</p>
<p>Any halted music will call any callback specified by <a class="el" href="#ab715ac2972aed61a2eaff4f980beb594" title="Set a callback that runs when a music object has stopped playing.">Mix_HookMusicFinished()</a> once the halt occurs.</p>
<p>Fading music will change it's volume progressively, as if <a class="el" href="#ab926fc25eab93de464ac7029e2125003" title="Set the volume for the music channel.">Mix_VolumeMusic()</a> was called on it (which is to say: you probably shouldn't call <a class="el" href="#ab926fc25eab93de464ac7029e2125003" title="Set the volume for the music channel.">Mix_VolumeMusic()</a> on a fading channel).</p>
<p>Note that this function does not block for the number of milliseconds requested; it just schedules the music to fade and notes the time for the mixer to manage later, and returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>number of milliseconds to fade before halting the channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if music was scheduled to fade, zero otherwise. If no music is currently playing, this returns zero.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="aeffa4c64b29f638f549defecdf7d9ddd" name="aeffa4c64b29f638f549defecdf7d9ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeffa4c64b29f638f549defecdf7d9ddd">&#9670;&#160;</a></span>Mix_FadingChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC <a class="el" href="#a362f2bccb8d01c337b0c6a934edd456c">Mix_Fading</a> SDLCALL Mix_FadingChannel </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>which</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the fading status of a channel. </p>
<p>This reports one of three values:</p>
<ul>
<li><code>MIX_NO_FADING</code></li>
<li><code>MIX_FADING_OUT</code></li>
<li><code>MIX_FADING_IN</code></li>
</ul>
<p>If nothing is currently playing on the channel, or an invalid channel is specified, this returns <code>MIX_NO_FADING</code>.</p>
<p>You may not specify MAX_CHANNEL_POST for a channel.</p>
<p>You may not specify -1 for all channels; only individual channels may be queried.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>the channel to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current fading status of the channel.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="afcb499a0686c714ede299e81e85c817c" name="afcb499a0686c714ede299e81e85c817c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb499a0686c714ede299e81e85c817c">&#9670;&#160;</a></span>Mix_FadingMusic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC <a class="el" href="#a362f2bccb8d01c337b0c6a934edd456c">Mix_Fading</a> SDLCALL Mix_FadingMusic </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the fading status of the music stream. </p>
<p>This reports one of three values:</p>
<ul>
<li><code>MIX_NO_FADING</code></li>
<li><code>MIX_FADING_OUT</code></li>
<li><code>MIX_FADING_IN</code></li>
</ul>
<p>If music is not currently playing, this returns <code>MIX_NO_FADING</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the current fading status of the music stream.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="abf7ae3433476bb4f66acedc6098e5b2d" name="abf7ae3433476bb4f66acedc6098e5b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7ae3433476bb4f66acedc6098e5b2d">&#9670;&#160;</a></span>Mix_FreeChunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC void SDLCALL Mix_FreeChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *</td>          <td class="paramname"><span class="paramname"><em>chunk</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free an audio chunk. </p>
<p>An app should call this function when it is done with a <a class="el" href="struct_mix___chunk.html" title="The internal format for an audio chunk.">Mix_Chunk</a> and wants to dispose of its resources.</p>
<p>SDL_mixer will stop any channels this chunk is currently playing on. This will deregister all effects on those channels and call any callback specified by <a class="el" href="#a8bb79c6f792464428d51b6aba1088b77" title="Set a callback that runs when a channel has finished playing.">Mix_ChannelFinished()</a> for each removed channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk</td><td>the chunk to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad673a76d5638a3a5df0abab5af156d34" title="Load a supported audio format into a chunk.">Mix_LoadWAV</a> </dd>
<dd>
<a class="el" href="#a623ad2f07078a0b0c9c8758fb3cc8f84" title="Load a supported audio format into a chunk.">Mix_LoadWAV_IO</a> </dd>
<dd>
<a class="el" href="#a6a2833e2d174d29d32ac514574ee8866" title="Load a WAV file from memory as quickly as possible.">Mix_QuickLoad_WAV</a> </dd>
<dd>
<a class="el" href="#a1e8da2bdfc6512b766235a3e9670462d" title="Load a raw audio data from memory as quickly as possible.">Mix_QuickLoad_RAW</a> </dd></dl>

</div>
</div>
<a id="ac2e103808706941aab379d601a46327b" name="ac2e103808706941aab379d601a46327b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e103808706941aab379d601a46327b">&#9670;&#160;</a></span>Mix_FreeMusic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC void SDLCALL Mix_FreeMusic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *</td>          <td class="paramname"><span class="paramname"><em>music</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free a music object. </p>
<p>If this music is currently playing, it will be stopped.</p>
<p>If this music is in the process of fading out (via <a class="el" href="#aff8cc2e99284bf7268b1ee62b86b5367" title="Halt the music stream after fading it out for a specified time.">Mix_FadeOutMusic()</a>), this function will <em>block</em> until the fade completes. If you need to avoid this, be sure to call <a class="el" href="#a2b2bc73786ee25eddb63208751baba76" title="Halt playing of the music stream.">Mix_HaltMusic()</a> before freeing the music.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music</td><td>the music object to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa283bfdf80dbb06db1548619fb3576ce" title="Load a supported audio format into a music object.">Mix_LoadMUS</a> </dd>
<dd>
<a class="el" href="#abff11b875d98188f6a50fbff734139a0" title="Load a supported audio format into a music object.">Mix_LoadMUS_IO</a> </dd>
<dd>
<a class="el" href="#a1ba9978eb01d83cc0ad42ec36949781f" title="Load an audio format into a music object, assuming a specific format.">Mix_LoadMUSType_IO</a> </dd></dl>

</div>
</div>
<a id="af37bb7b694296e52f97d22822a2057b8" name="af37bb7b694296e52f97d22822a2057b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37bb7b694296e52f97d22822a2057b8">&#9670;&#160;</a></span>Mix_GetChunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC <a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *SDLCALL Mix_GetChunk </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="struct_mix___chunk.html" title="The internal format for an audio chunk.">Mix_Chunk</a> currently associated with a mixer channel. </p>
<p>You may not specify MAX_CHANNEL_POST or -1 for a channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated chunk, if any, or NULL if it's an invalid channel.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a3aa645fef7a0febfb5a841eca0585e7d" name="a3aa645fef7a0febfb5a841eca0585e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa645fef7a0febfb5a841eca0585e7d">&#9670;&#160;</a></span>Mix_GetChunkDecoder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC const char *SDLCALL Mix_GetChunkDecoder </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a chunk decoder's name. </p>
<p>The requested decoder's index must be between zero and <a class="el" href="#a96a0798b1d506b9231fc8bf249cc205a" title="Get a list of chunk decoders that this build of SDL_mixer provides.">Mix_GetNumChunkDecoders()</a>-1. It's safe to call this with an invalid index; this function will return NULL in that case.</p>
<p>This list can change between builds AND runs of the program, if external libraries that add functionality become available. You must successfully call <a class="el" href="#a23afb407fa3a9766f21d07ea43bee1cd" title="Open an audio device for playback.">Mix_OpenAudio()</a> before calling this function, as decoders are activated at device open time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the chunk decoder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the chunk decoder's name.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a96a0798b1d506b9231fc8bf249cc205a" title="Get a list of chunk decoders that this build of SDL_mixer provides.">Mix_GetNumChunkDecoders</a> </dd></dl>

</div>
</div>
<a id="a00d322897b0c7700311df2dd835ab027" name="a00d322897b0c7700311df2dd835ab027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d322897b0c7700311df2dd835ab027">&#9670;&#160;</a></span>Mix_GetMusicAlbumTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC const char *SDLCALL Mix_GetMusicAlbumTag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *</td>          <td class="paramname"><span class="paramname"><em>music</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the album name for a music object. </p>
<p>This returns format-specific metadata. Not all file formats supply this!</p>
<p>If <code>music</code> is NULL, this will query the currently-playing music.</p>
<p>This function never returns NULL! If no data is available, it will return an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music</td><td>the music object to query, or NULL for the currently-playing music. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the music's album name if available, or "".</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a285662440916db1fa0949ab7e48e7e90" title="Get the title for a music object.">Mix_GetMusicTitleTag</a> </dd>
<dd>
<a class="el" href="#a985ef119ec4cc0f52f0e848930cc20d6" title="Get the artist name for a music object.">Mix_GetMusicArtistTag</a> </dd>
<dd>
<a class="el" href="#a327b3dcabc52c4a92f7d2ba4a9a8bde9" title="Get the copyright text for a music object.">Mix_GetMusicCopyrightTag</a> </dd></dl>

</div>
</div>
<a id="a985ef119ec4cc0f52f0e848930cc20d6" name="a985ef119ec4cc0f52f0e848930cc20d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985ef119ec4cc0f52f0e848930cc20d6">&#9670;&#160;</a></span>Mix_GetMusicArtistTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC const char *SDLCALL Mix_GetMusicArtistTag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *</td>          <td class="paramname"><span class="paramname"><em>music</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the artist name for a music object. </p>
<p>This returns format-specific metadata. Not all file formats supply this!</p>
<p>If <code>music</code> is NULL, this will query the currently-playing music.</p>
<p>This function never returns NULL! If no data is available, it will return an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music</td><td>the music object to query, or NULL for the currently-playing music. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the music's artist name if available, or "".</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a285662440916db1fa0949ab7e48e7e90" title="Get the title for a music object.">Mix_GetMusicTitleTag</a> </dd>
<dd>
<a class="el" href="#a00d322897b0c7700311df2dd835ab027" title="Get the album name for a music object.">Mix_GetMusicAlbumTag</a> </dd>
<dd>
<a class="el" href="#a327b3dcabc52c4a92f7d2ba4a9a8bde9" title="Get the copyright text for a music object.">Mix_GetMusicCopyrightTag</a> </dd></dl>

</div>
</div>
<a id="a327b3dcabc52c4a92f7d2ba4a9a8bde9" name="a327b3dcabc52c4a92f7d2ba4a9a8bde9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327b3dcabc52c4a92f7d2ba4a9a8bde9">&#9670;&#160;</a></span>Mix_GetMusicCopyrightTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC const char *SDLCALL Mix_GetMusicCopyrightTag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *</td>          <td class="paramname"><span class="paramname"><em>music</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the copyright text for a music object. </p>
<p>This returns format-specific metadata. Not all file formats supply this!</p>
<p>If <code>music</code> is NULL, this will query the currently-playing music.</p>
<p>This function never returns NULL! If no data is available, it will return an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music</td><td>the music object to query, or NULL for the currently-playing music. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the music's copyright text if available, or "".</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a285662440916db1fa0949ab7e48e7e90" title="Get the title for a music object.">Mix_GetMusicTitleTag</a> </dd>
<dd>
<a class="el" href="#a985ef119ec4cc0f52f0e848930cc20d6" title="Get the artist name for a music object.">Mix_GetMusicArtistTag</a> </dd>
<dd>
<a class="el" href="#a00d322897b0c7700311df2dd835ab027" title="Get the album name for a music object.">Mix_GetMusicAlbumTag</a> </dd></dl>

</div>
</div>
<a id="a373d0fa4f158f0731564710d547c9a17" name="a373d0fa4f158f0731564710d547c9a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373d0fa4f158f0731564710d547c9a17">&#9670;&#160;</a></span>Mix_GetMusicDecoder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC const char *SDLCALL Mix_GetMusicDecoder </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a music decoder's name. </p>
<p>The requested decoder's index must be between zero and <a class="el" href="#acd9256e344e9916e15764a4e39d428de" title="Get a list of music decoders that this build of SDL_mixer provides.">Mix_GetNumMusicDecoders()</a>-1. It's safe to call this with an invalid index; this function will return NULL in that case.</p>
<p>This list can change between builds AND runs of the program, if external libraries that add functionality become available. You must successfully call <a class="el" href="#a23afb407fa3a9766f21d07ea43bee1cd" title="Open an audio device for playback.">Mix_OpenAudio()</a> before calling this function, as decoders are activated at device open time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the music decoder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the music decoder's name.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#acd9256e344e9916e15764a4e39d428de" title="Get a list of music decoders that this build of SDL_mixer provides.">Mix_GetNumMusicDecoders</a> </dd></dl>

</div>
</div>
<a id="ac7de033c57de248ad0737b710e64cd5c" name="ac7de033c57de248ad0737b710e64cd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7de033c57de248ad0737b710e64cd5c">&#9670;&#160;</a></span>Mix_GetMusicHookData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC void *SDLCALL Mix_GetMusicHookData </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the user data for the current music hook. </p>
<p>This returns the <code>arg</code> pointer last passed to <a class="el" href="#a9c7889c7e4fd6c846e6ddf68a6b8eb12" title="Add your own music player or additional mixer function.">Mix_HookMusic()</a>, or NULL if that function has never been called.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the user data previously passed to Mix_HookMusic.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a147b90403524bda784e13e92b167b9f3" name="a147b90403524bda784e13e92b167b9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147b90403524bda784e13e92b167b9f3">&#9670;&#160;</a></span>Mix_GetMusicLoopEndTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC double SDLCALL Mix_GetMusicLoopEndTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *</td>          <td class="paramname"><span class="paramname"><em>music</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the loop end time position of music stream, in seconds. </p>
<p>To convert to milliseconds, multiply by 1000.0.</p>
<p>If NULL is passed, returns duration of current playing music.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music</td><td>the music object to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1.0 if this feature is not used for this music or not supported for some codec</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a3344603f591526435d11ef3a7352b900" name="a3344603f591526435d11ef3a7352b900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3344603f591526435d11ef3a7352b900">&#9670;&#160;</a></span>Mix_GetMusicLoopLengthTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC double SDLCALL Mix_GetMusicLoopLengthTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *</td>          <td class="paramname"><span class="paramname"><em>music</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the loop time length of music stream, in seconds. </p>
<p>To convert to milliseconds, multiply by 1000.0.</p>
<p>If NULL is passed, returns duration of current playing music.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music</td><td>the music object to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1.0 if this feature is not used for this music or not supported for some codec</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="abc569e50d4ae6a243feecde69425633f" name="abc569e50d4ae6a243feecde69425633f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc569e50d4ae6a243feecde69425633f">&#9670;&#160;</a></span>Mix_GetMusicLoopStartTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC double SDLCALL Mix_GetMusicLoopStartTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *</td>          <td class="paramname"><span class="paramname"><em>music</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the loop start time position of music stream, in seconds. </p>
<p>To convert to milliseconds, multiply by 1000.0.</p>
<p>If NULL is passed, returns duration of current playing music.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music</td><td>the music object to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1.0 if this feature is not used for this music or not supported for some codec</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a6cb2ce798a35d9a661329128b40e4430" name="a6cb2ce798a35d9a661329128b40e4430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb2ce798a35d9a661329128b40e4430">&#9670;&#160;</a></span>Mix_GetMusicPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC double SDLCALL Mix_GetMusicPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *</td>          <td class="paramname"><span class="paramname"><em>music</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the time current position of music stream, in seconds. </p>
<p>To convert to milliseconds, multiply by 1000.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music</td><td>the music object to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1.0 if this feature is not supported for some codec.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a8aa549f3835d4695340f687d1c381b8a" name="a8aa549f3835d4695340f687d1c381b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa549f3835d4695340f687d1c381b8a">&#9670;&#160;</a></span>Mix_GetMusicTitle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC const char *SDLCALL Mix_GetMusicTitle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *</td>          <td class="paramname"><span class="paramname"><em>music</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the title for a music object, or its filename. </p>
<p>This returns format-specific metadata. Not all file formats supply this!</p>
<p>If <code>music</code> is NULL, this will query the currently-playing music.</p>
<p>If music's title tag is missing or empty, the filename will be returned. If you'd rather have the actual metadata or nothing, use <a class="el" href="#a285662440916db1fa0949ab7e48e7e90" title="Get the title for a music object.">Mix_GetMusicTitleTag()</a> instead.</p>
<p>Please note that if the music was loaded from an SDL_IOStream instead of a filename, the filename returned will be an empty string ("").</p>
<p>This function never returns NULL! If no data is available, it will return an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music</td><td>the music object to query, or NULL for the currently-playing music. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the music's title if available, or the filename if not, or "".</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a285662440916db1fa0949ab7e48e7e90" title="Get the title for a music object.">Mix_GetMusicTitleTag</a> </dd>
<dd>
<a class="el" href="#a985ef119ec4cc0f52f0e848930cc20d6" title="Get the artist name for a music object.">Mix_GetMusicArtistTag</a> </dd>
<dd>
<a class="el" href="#a00d322897b0c7700311df2dd835ab027" title="Get the album name for a music object.">Mix_GetMusicAlbumTag</a> </dd>
<dd>
<a class="el" href="#a327b3dcabc52c4a92f7d2ba4a9a8bde9" title="Get the copyright text for a music object.">Mix_GetMusicCopyrightTag</a> </dd></dl>

</div>
</div>
<a id="a285662440916db1fa0949ab7e48e7e90" name="a285662440916db1fa0949ab7e48e7e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285662440916db1fa0949ab7e48e7e90">&#9670;&#160;</a></span>Mix_GetMusicTitleTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC const char *SDLCALL Mix_GetMusicTitleTag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *</td>          <td class="paramname"><span class="paramname"><em>music</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the title for a music object. </p>
<p>This returns format-specific metadata. Not all file formats supply this!</p>
<p>If <code>music</code> is NULL, this will query the currently-playing music.</p>
<p>Unlike this function, <a class="el" href="#a8aa549f3835d4695340f687d1c381b8a" title="Get the title for a music object, or its filename.">Mix_GetMusicTitle()</a> produce a string with the music's filename if a title isn't available, which might be preferable for some applications.</p>
<p>This function never returns NULL! If no data is available, it will return an empty string ("").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music</td><td>the music object to query, or NULL for the currently-playing music. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the music's title if available, or "".</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8aa549f3835d4695340f687d1c381b8a" title="Get the title for a music object, or its filename.">Mix_GetMusicTitle</a> </dd>
<dd>
<a class="el" href="#a985ef119ec4cc0f52f0e848930cc20d6" title="Get the artist name for a music object.">Mix_GetMusicArtistTag</a> </dd>
<dd>
<a class="el" href="#a00d322897b0c7700311df2dd835ab027" title="Get the album name for a music object.">Mix_GetMusicAlbumTag</a> </dd>
<dd>
<a class="el" href="#a327b3dcabc52c4a92f7d2ba4a9a8bde9" title="Get the copyright text for a music object.">Mix_GetMusicCopyrightTag</a> </dd></dl>

</div>
</div>
<a id="a067102de8c25361537caa4165ce5eeae" name="a067102de8c25361537caa4165ce5eeae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067102de8c25361537caa4165ce5eeae">&#9670;&#160;</a></span>Mix_GetMusicType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC <a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46">Mix_MusicType</a> SDLCALL Mix_GetMusicType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *</td>          <td class="paramname"><span class="paramname"><em>music</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find out the format of a mixer music. </p>
<p>If <code>music</code> is NULL, this will query the currently playing music (and return MUS_NONE if nothing is currently playing).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music</td><td>the music object to query, or NULL for the currently-playing music. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Mix_MusicType for the music object.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0 </dd></dl>

</div>
</div>
<a id="ad7ae48f64daaef414b1cd9255de4c26d" name="ad7ae48f64daaef414b1cd9255de4c26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ae48f64daaef414b1cd9255de4c26d">&#9670;&#160;</a></span>Mix_GetMusicVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_GetMusicVolume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *</td>          <td class="paramname"><span class="paramname"><em>music</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the current volume value for a music object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music</td><td>the music object to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the music's current volume, between 0 and MIX_MAX_VOLUME (128).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a96a0798b1d506b9231fc8bf249cc205a" name="a96a0798b1d506b9231fc8bf249cc205a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a0798b1d506b9231fc8bf249cc205a">&#9670;&#160;</a></span>Mix_GetNumChunkDecoders()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_GetNumChunkDecoders </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a list of chunk decoders that this build of SDL_mixer provides. </p>
<p>This list can change between builds AND runs of the program, if external libraries that add functionality become available. You must successfully call <a class="el" href="#a23afb407fa3a9766f21d07ea43bee1cd" title="Open an audio device for playback.">Mix_OpenAudio()</a> before calling this function, as decoders are activated at device open time.</p>
<p>Appearing in this list doesn't promise your specific audio file will decode...but it's handy to know if you have, say, a functioning Ogg Vorbis install.</p>
<p>These return values are static, read-only data; do not modify or free it. The pointers remain valid until you call <a class="el" href="#a2cb071e94923956f4c3ca4d3998669e7" title="Close the mixer, halting all playing audio.">Mix_CloseAudio()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>number of chunk decoders available.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3aa645fef7a0febfb5a841eca0585e7d" title="Get a chunk decoder&#39;s name.">Mix_GetChunkDecoder</a> </dd>
<dd>
<a class="el" href="#a4d47159d90b111fdb8b76002519d4e57" title="Check if a chunk decoder is available by name.">Mix_HasChunkDecoder</a> </dd></dl>

</div>
</div>
<a id="acd9256e344e9916e15764a4e39d428de" name="acd9256e344e9916e15764a4e39d428de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9256e344e9916e15764a4e39d428de">&#9670;&#160;</a></span>Mix_GetNumMusicDecoders()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_GetNumMusicDecoders </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a list of music decoders that this build of SDL_mixer provides. </p>
<p>This list can change between builds AND runs of the program, if external libraries that add functionality become available. You must successfully call <a class="el" href="#a23afb407fa3a9766f21d07ea43bee1cd" title="Open an audio device for playback.">Mix_OpenAudio()</a> before calling this function, as decoders are activated at device open time.</p>
<p>Appearing in this list doesn't promise your specific audio file will decode...but it's handy to know if you have, say, a functioning Ogg Vorbis install.</p>
<p>These return values are static, read-only data; do not modify or free it. The pointers remain valid until you call <a class="el" href="#a2cb071e94923956f4c3ca4d3998669e7" title="Close the mixer, halting all playing audio.">Mix_CloseAudio()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>number of music decoders available.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a373d0fa4f158f0731564710d547c9a17" title="Get a music decoder&#39;s name.">Mix_GetMusicDecoder</a> </dd>
<dd>
<a class="el" href="#aebece8a3134f9bdf850997af8c479163" title="Check if a music decoder is available by name.">Mix_HasMusicDecoder</a> </dd></dl>

</div>
</div>
<a id="a8db88b2c1c4a875876695bcc0cd6f0f9" name="a8db88b2c1c4a875876695bcc0cd6f0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db88b2c1c4a875876695bcc0cd6f0f9">&#9670;&#160;</a></span>Mix_GetNumTracks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_GetNumTracks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *</td>          <td class="paramname"><span class="paramname"><em>music</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of tracks in music object. </p>
<p>This only applies to GME music formats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music</td><td>the music object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of tracks if successful, or -1 if failed or isn't implemented.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="ae72fa4f7aedbb2b881483e4b89f5a2a2" name="ae72fa4f7aedbb2b881483e4b89f5a2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72fa4f7aedbb2b881483e4b89f5a2a2">&#9670;&#160;</a></span>Mix_GetSoundFonts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC const char *SDLCALL Mix_GetSoundFonts </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get SoundFonts paths to use by supported MIDI backends. </p>
<p>There are several factors that determine what will be reported by this function:</p>
<ul>
<li>If the boolean <em>SDL hint</em> <code>"SDL_FORCE_SOUNDFONTS"</code> is set, AND the <code>"SDL_SOUNDFONTS"</code> <em>environment variable</em> is also set, this function will return that environment variable regardless of whether Mix_SetSoundFounts() was ever called.</li>
<li>Otherwise, if <a class="el" href="#aa503e9b83c9fbf14496d93947568de8f" title="Set SoundFonts paths to use by supported MIDI backends.">Mix_SetSoundFonts()</a> was successfully called with a non-NULL path, this function will return the string passed to that function.</li>
<li>Otherwise, if the <code>"SDL_SOUNDFONTS"</code> variable is set, this function will return that environment variable.</li>
<li>Otherwise, this function will search some common locations on the filesystem, and if it finds a SoundFont there, it will return that.</li>
<li>Failing everything else, this function returns NULL.</li>
</ul>
<p>This returns a pointer to internal (possibly read-only) memory, and it should not be modified or free'd by the caller.</p>
<dl class="section return"><dt>Returns</dt><dd>semicolon-separated list of sound font paths.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="aa614da725f8c139b50af9d79c62d79e0" name="aa614da725f8c139b50af9d79c62d79e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa614da725f8c139b50af9d79c62d79e0">&#9670;&#160;</a></span>Mix_GetSynchroValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_GetSynchroValue </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function does nothing, do not use. </p>
<p>This was probably meant to expose a feature, but no codecs support it, so it only remains for binary compatibility.</p>
<p>Calling this function is a legal no-op that returns -1.</p>
<dl class="section return"><dt>Returns</dt><dd>-1.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a1405ea91714d0163795f88e2b7903668" name="a1405ea91714d0163795f88e2b7903668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1405ea91714d0163795f88e2b7903668">&#9670;&#160;</a></span>Mix_GetTimidityCfg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC const char *SDLCALL Mix_GetTimidityCfg </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get full path of a previously-specified Timidity config file. </p>
<p>For example, "/etc/timidity.cfg"</p>
<p>If a path has never been specified, this returns NULL.</p>
<p>This returns a pointer to internal memory, and it should not be modified or free'd by the caller.</p>
<dl class="section return"><dt>Returns</dt><dd>the previously-specified path, or NULL if not set.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#acd9d1061909d9b80853034120735fd57" title="Set full path of the Timidity config file.">Mix_SetTimidityCfg</a> </dd></dl>

</div>
</div>
<a id="ae4b751351d0554c264a0d1abc02d832c" name="ae4b751351d0554c264a0d1abc02d832c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b751351d0554c264a0d1abc02d832c">&#9670;&#160;</a></span>Mix_GroupAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_GroupAvailable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first available channel in a group of channels. </p>
<p>A tag is an arbitrary number that can be assigned to several mixer channels, to form groups of channels.</p>
<p>This function searches all channels with a specified tag, and returns the channel number of the first one it finds that is currently unused.</p>
<p>If no channels with the specified tag are unused, this function returns -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>an arbitrary value, assigned to channels, to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first available channel, or -1 if none are available.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="ab0ce85d3ea72e1d14e1fbd15bbf8cfd1" name="ab0ce85d3ea72e1d14e1fbd15bbf8cfd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ce85d3ea72e1d14e1fbd15bbf8cfd1">&#9670;&#160;</a></span>Mix_GroupChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_GroupChannel </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>which</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a tag to a channel. </p>
<p>A tag is an arbitrary number that can be assigned to several mixer channels, to form groups of channels.</p>
<p>If 'tag' is -1, the tag is removed (actually -1 is the tag used to represent the group of all the channels).</p>
<p>This function replaces the requested channel's current tag; you may only have one tag per channel.</p>
<p>You may not specify MAX_CHANNEL_POST for a channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>the channel to set the tag on. </td></tr>
    <tr><td class="paramname">tag</td><td>an arbitrary value to assign a channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero on success, zero on error (no such channel).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="aee8ff77b8e446e449701371a0c8cc522" name="aee8ff77b8e446e449701371a0c8cc522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8ff77b8e446e449701371a0c8cc522">&#9670;&#160;</a></span>Mix_GroupChannels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_GroupChannels </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>from</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>to</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign several consecutive channels to the same tag. </p>
<p>A tag is an arbitrary number that can be assigned to several mixer channels, to form groups of channels.</p>
<p>If 'tag' is -1, the tag is removed (actually -1 is the tag used to represent the group of all the channels).</p>
<p>This function replaces the requested channels' current tags; you may only have one tag per channel.</p>
<p>You may not specify MAX_CHANNEL_POST for a channel.</p>
<p>Note that this returns success and failure in the <em>opposite</em> way from <a class="el" href="#ab0ce85d3ea72e1d14e1fbd15bbf8cfd1" title="Assign a tag to a channel.">Mix_GroupChannel()</a>. We regret the API design mistake.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first channel to set the tag on. </td></tr>
    <tr><td class="paramname">to</td><td>the last channel to set the tag on, inclusive. </td></tr>
    <tr><td class="paramname">tag</td><td>an arbitrary value to assign a channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, negative on error</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a43ca84ed285330500b98b7731710e26f" name="a43ca84ed285330500b98b7731710e26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ca84ed285330500b98b7731710e26f">&#9670;&#160;</a></span>Mix_GroupCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_GroupCount </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of channels in a group. </p>
<p>If tag is -1, this will return the total number of channels allocated, regardless of what their tag might be.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>an arbitrary value, assigned to channels, to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of channels assigned the specified tag.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a598ff819d5c839f199183ed997855d83" name="a598ff819d5c839f199183ed997855d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598ff819d5c839f199183ed997855d83">&#9670;&#160;</a></span>Mix_GroupNewer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_GroupNewer </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the "most recent" sample playing in a group of channels. </p>
<p>Specifically, this function returns the channel number that is assigned the specified tag, is currently playing, and has the highest start time, based on the value of SDL_GetTicks() when the channel started playing.</p>
<p>If no channel with this tag is currently playing, this function returns -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>an arbitrary value, assigned to channels, to search through. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the "most recent" sample playing in a group of channels</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a97e7c63dab34fa0a964442e90fd4d416" title="Find the &quot;oldest&quot; sample playing in a group of channels.">Mix_GroupOldest</a> </dd></dl>

</div>
</div>
<a id="a97e7c63dab34fa0a964442e90fd4d416" name="a97e7c63dab34fa0a964442e90fd4d416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e7c63dab34fa0a964442e90fd4d416">&#9670;&#160;</a></span>Mix_GroupOldest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_GroupOldest </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the "oldest" sample playing in a group of channels. </p>
<p>Specifically, this function returns the channel number that is assigned the specified tag, is currently playing, and has the lowest start time, based on the value of SDL_GetTicks() when the channel started playing.</p>
<p>If no channel with this tag is currently playing, this function returns -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>an arbitrary value, assigned to channels, to search through. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the "oldest" sample playing in a group of channels</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a598ff819d5c839f199183ed997855d83" title="Find the &quot;most recent&quot; sample playing in a group of channels.">Mix_GroupNewer</a> </dd></dl>

</div>
</div>
<a id="a369f1cc25e69d0dc2a6f652109de9683" name="a369f1cc25e69d0dc2a6f652109de9683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369f1cc25e69d0dc2a6f652109de9683">&#9670;&#160;</a></span>Mix_HaltChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_HaltChannel </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Halt playing of a particular channel. </p>
<p>This will stop further playback on that channel until a new chunk is started there.</p>
<p>Specifying a channel of -1 will halt <em>all</em> channels, except for any playing music.</p>
<p>Any halted channels will have any currently-registered effects deregistered, and will call any callback specified by <a class="el" href="#a8bb79c6f792464428d51b6aba1088b77" title="Set a callback that runs when a channel has finished playing.">Mix_ChannelFinished()</a> before this function returns.</p>
<p>You may not specify MAX_CHANNEL_POST for a channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>channel to halt, or -1 to halt all channels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or -1 on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="ab3f97cb41be6a1b4c3d638cc9aaa7043" name="ab3f97cb41be6a1b4c3d638cc9aaa7043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f97cb41be6a1b4c3d638cc9aaa7043">&#9670;&#160;</a></span>Mix_HaltGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_HaltGroup </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Halt playing of a group of channels by arbitrary tag. </p>
<p>This will stop further playback on all channels with a specific tag, until a new chunk is started there.</p>
<p>A tag is an arbitrary number that can be assigned to several mixer channels, to form groups of channels.</p>
<p>The default tag for a channel is -1.</p>
<p>Any halted channels will have any currently-registered effects deregistered, and will call any callback specified by <a class="el" href="#a8bb79c6f792464428d51b6aba1088b77" title="Set a callback that runs when a channel has finished playing.">Mix_ChannelFinished()</a> before this function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>an arbitrary value, assigned to channels, to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero, whether any channels were halted or not.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a2b2bc73786ee25eddb63208751baba76" name="a2b2bc73786ee25eddb63208751baba76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2bc73786ee25eddb63208751baba76">&#9670;&#160;</a></span>Mix_HaltMusic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_HaltMusic </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Halt playing of the music stream. </p>
<p>This will stop further playback of music until a new music object is started there.</p>
<p>Any halted music will call any callback specified by <a class="el" href="#ab715ac2972aed61a2eaff4f980beb594" title="Set a callback that runs when a music object has stopped playing.">Mix_HookMusicFinished()</a> before this function returns.</p>
<dl class="section return"><dt>Returns</dt><dd>zero, regardless of whether any music was halted.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a4d47159d90b111fdb8b76002519d4e57" name="a4d47159d90b111fdb8b76002519d4e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d47159d90b111fdb8b76002519d4e57">&#9670;&#160;</a></span>Mix_HasChunkDecoder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC SDL_bool SDLCALL Mix_HasChunkDecoder </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a chunk decoder is available by name. </p>
<p>This result can change between builds AND runs of the program, if external libraries that add functionality become available. You must successfully call <a class="el" href="#a23afb407fa3a9766f21d07ea43bee1cd" title="Open an audio device for playback.">Mix_OpenAudio()</a> before calling this function, as decoders are activated at device open time.</p>
<p>Decoder names are arbitrary but also obvious, so you have to know what you're looking for ahead of time, but usually it's the file extension in capital letters (some example names are "AIFF", "VOC", "WAV").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the decoder name to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SDL_TRUE if a decoder by that name is available, SDL_FALSE otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a96a0798b1d506b9231fc8bf249cc205a" title="Get a list of chunk decoders that this build of SDL_mixer provides.">Mix_GetNumChunkDecoders</a> </dd>
<dd>
<a class="el" href="#a3aa645fef7a0febfb5a841eca0585e7d" title="Get a chunk decoder&#39;s name.">Mix_GetChunkDecoder</a> </dd></dl>

</div>
</div>
<a id="aebece8a3134f9bdf850997af8c479163" name="aebece8a3134f9bdf850997af8c479163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebece8a3134f9bdf850997af8c479163">&#9670;&#160;</a></span>Mix_HasMusicDecoder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC SDL_bool SDLCALL Mix_HasMusicDecoder </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a music decoder is available by name. </p>
<p>This result can change between builds AND runs of the program, if external libraries that add functionality become available. You must successfully call <a class="el" href="#a23afb407fa3a9766f21d07ea43bee1cd" title="Open an audio device for playback.">Mix_OpenAudio()</a> before calling this function, as decoders are activated at device open time.</p>
<p>Decoder names are arbitrary but also obvious, so you have to know what you're looking for ahead of time, but usually it's the file extension in capital letters (some example names are "MOD", "MP3", "FLAC").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the decoder name to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SDL_TRUE if a decoder by that name is available, SDL_FALSE otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#acd9256e344e9916e15764a4e39d428de" title="Get a list of music decoders that this build of SDL_mixer provides.">Mix_GetNumMusicDecoders</a> </dd>
<dd>
<a class="el" href="#a373d0fa4f158f0731564710d547c9a17" title="Get a music decoder&#39;s name.">Mix_GetMusicDecoder</a> </dd></dl>

</div>
</div>
<a id="a9c7889c7e4fd6c846e6ddf68a6b8eb12" name="a9c7889c7e4fd6c846e6ddf68a6b8eb12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7889c7e4fd6c846e6ddf68a6b8eb12">&#9670;&#160;</a></span>Mix_HookMusic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC void SDLCALL Mix_HookMusic </td>
          <td>(</td>
          <td class="paramtype">void(SDLCALL *mix_func)(void *udata, Uint8 *stream, int len)</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add your own music player or additional mixer function. </p>
<p>This works something like <a class="el" href="#a7dc4ec0f09fd676d9d7569550d866ca7" title="Set a function that is called after all mixing is performed.">Mix_SetPostMix()</a>, but it has some crucial differences. Note that an app can use this <em>and</em> <a class="el" href="#a7dc4ec0f09fd676d9d7569550d866ca7" title="Set a function that is called after all mixing is performed.">Mix_SetPostMix()</a> at the same time. This allows an app to replace the built-in music playback, either with it's own music decoder or with some sort of procedurally-generated audio output.</p>
<p>The supplied callback will fire every time SDL_mixer is preparing to supply more data to the audio device. This runs inside an SDL audio callback, so it's important that the callback return quickly, or there could be problems in the audio playback.</p>
<p>Running this callback is the first thing SDL_mixer will do when starting to mix more audio. The buffer will contain silence upon entry, so the callback does not need to mix into existing data or initialize the buffer.</p>
<p>Note that while a callback is set through this function, SDL_mixer will not mix any playing music; this callback is used instead. To disable this callback (and thus reenable built-in music playback) call this function with a NULL callback.</p>
<p>The data written to by the callback is in the format that the audio device was opened in, and upon return from the callback, SDL_mixer will mix any playing chunks (but not music!) into the buffer. The callback cannot resize the buffer (so you must be prepared to provide exactly the amount of data demanded or leave it as silence).</p>
<p>The <code>arg</code> pointer supplied here is passed to the callback as-is, for whatever the callback might want to do with it (keep track of some ongoing state, settings, etc).</p>
<p>As there is only one music "channel" mixed, there is only one callback available. If you need to mix multiple inputs, be prepared to handle them from a single function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mix_func</td><td>the callback function to become the new post-mix callback. </td></tr>
    <tr><td class="paramname">arg</td><td>a pointer that is passed, untouched, to the callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7dc4ec0f09fd676d9d7569550d866ca7" title="Set a function that is called after all mixing is performed.">Mix_SetPostMix</a> </dd></dl>

</div>
</div>
<a id="ab715ac2972aed61a2eaff4f980beb594" name="ab715ac2972aed61a2eaff4f980beb594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab715ac2972aed61a2eaff4f980beb594">&#9670;&#160;</a></span>Mix_HookMusicFinished()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC void SDLCALL Mix_HookMusicFinished </td>
          <td>(</td>
          <td class="paramtype">void(SDLCALL *music_finished)(void)</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a callback that runs when a music object has stopped playing. </p>
<p>This callback will fire when the currently-playing music has completed, or when it has been explicitly stopped from a call to Mix_HaltMusic. As such, this callback might fire from an arbitrary background thread at almost any time; try to limit what you do here.</p>
<p>It is legal to start a new music object playing in this callback (or restart the one that just stopped). If the music finished normally, this can be used to loop the music without a gap in the audio playback.</p>
<p>Do not call SDL_LockAudio() from this callback; you will either be inside the audio callback, or SDL_mixer will explicitly lock the audio before calling your callback.</p>
<p>A NULL pointer will disable the callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music_finished</td><td>the callback function to become the new notification mechanism.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a71a389ff8fb5e4af34d0951e73d05995" name="a71a389ff8fb5e4af34d0951e73d05995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a389ff8fb5e4af34d0951e73d05995">&#9670;&#160;</a></span>Mix_Init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_Init </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize SDL_mixer. </p>
<p>This function loads dynamic libraries that SDL_mixer needs, and prepares them for use.</p>
<p>Note that, unlike other SDL libraries, this call is optional! If you load a music file, SDL_mixer will handle initialization on the fly. This function will let you know, up front, whether a specific format will be available for use.</p>
<p>Flags should be one or more flags from MIX_InitFlags OR'd together. It returns the flags successfully initialized, or 0 on failure.</p>
<p>Currently, these flags are:</p>
<ul>
<li><code>MIX_INIT_FLAC</code></li>
<li><code>MIX_INIT_MOD</code></li>
<li><code>MIX_INIT_MP3</code></li>
<li><code>MIX_INIT_OGG</code></li>
<li><code>MIX_INIT_MID</code></li>
<li><code>MIX_INIT_OPUS</code></li>
<li><code>MIX_INIT_WAVPACK</code></li>
</ul>
<p>More flags may be added in a future SDL_mixer release.</p>
<p>This function may need to load external shared libraries to support various codecs, which means this function can fail to initialize that support on an otherwise-reasonable system if the library isn't available; this is not just a question of exceptional circumstances like running out of memory at startup!</p>
<p>Note that you may call this function more than once to initialize with additional flags. The return value will reflect both new flags that successfully initialized, and also include flags that had previously been initialized as well.</p>
<p>As this will return previously-initialized flags, it's legal to call this with zero (no flags set). This is a safe no-op that can be used to query the current initialization state without changing it at all.</p>
<p>Since this returns previously-initialized flags as well as new ones, and you can call this with zero, you should not check for a zero return value to determine an error condition. Instead, you should check to make sure all the flags you require are set in the return value. If you have a game with data in a specific format, this might be a fatal error. If you're a generic media player, perhaps you are fine with only having WAV and MP3 support and can live without Opus playback, even if you request support for everything.</p>
<p>Unlike other SDL satellite libraries, calls to Mix_Init do not stack; a single call to <a class="el" href="#a136e5586b53fe0e3e752e2174bd7bb70" title="Deinitialize SDL_mixer.">Mix_Quit()</a> will deinitialize everything and does not have to be paired with a matching Mix_Init call. For that reason, it's considered best practices to have a single Mix_Init and Mix_Quit call in your program. While this isn't required, be aware of the risks of deviating from that behavior.</p>
<p>After initializing SDL_mixer, the next step is to open an audio device to prepare to play sound (with <a class="el" href="#a23afb407fa3a9766f21d07ea43bee1cd" title="Open an audio device for playback.">Mix_OpenAudio()</a>), and load audio data to play with that device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>initialization flags, OR'd together. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>all currently initialized flags.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a136e5586b53fe0e3e752e2174bd7bb70" title="Deinitialize SDL_mixer.">Mix_Quit</a> </dd></dl>

</div>
</div>
<a id="a2706949e601bd6ef831597074dd8c5fd" name="a2706949e601bd6ef831597074dd8c5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2706949e601bd6ef831597074dd8c5fd">&#9670;&#160;</a></span>Mix_Linked_Version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC const SDL_Version *SDLCALL Mix_Linked_Version </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the version of SDL_mixer that the program is linked against. </p>
<p>This function gets the version of the dynamically linked SDL_mixer library. This is separate from the <a class="el" href="#ad6f12d4cf70382836dc0129afe796365" title="This macro can be used to fill a version structure with the compile-time version of the SDL_mixer lib...">SDL_MIXER_VERSION()</a> macro, which tells you what version of the SDL_mixer headers you compiled against.</p>
<p>This returns static internal data; do not free or modify it!</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the version information.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="aa283bfdf80dbb06db1548619fb3576ce" name="aa283bfdf80dbb06db1548619fb3576ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa283bfdf80dbb06db1548619fb3576ce">&#9670;&#160;</a></span>Mix_LoadMUS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *SDLCALL Mix_LoadMUS </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a supported audio format into a music object. </p>
<p>SDL_mixer has two separate data structures for audio data. One it calls a "chunk," which is meant to be a file completely decoded into memory up front, and the other it calls "music" which is a file intended to be decoded on demand. Originally, simple formats like uncompressed WAV files were meant to be chunks and compressed things, like MP3s, were meant to be music, and you would stream one thing for a game's music and make repeating sound effects with the chunks.</p>
<p>In modern times, this isn't split by format anymore, and most are interchangeable, so the question is what the app thinks is worth predecoding or not. Chunks might take more memory, but once they are loaded won't need to decode again, whereas music always needs to be decoded on the fly. Also, crucially, there are as many channels for chunks as the app can allocate, but SDL_mixer only offers a single "music" channel.</p>
<p>When done with this music, the app should dispose of it with a call to <a class="el" href="#ac2e103808706941aab379d601a46327b" title="Free a music object.">Mix_FreeMusic()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>a file path from where to load music data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new music object, or NULL on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac2e103808706941aab379d601a46327b" title="Free a music object.">Mix_FreeMusic</a> </dd></dl>

</div>
</div>
<a id="abff11b875d98188f6a50fbff734139a0" name="abff11b875d98188f6a50fbff734139a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff11b875d98188f6a50fbff734139a0">&#9670;&#160;</a></span>Mix_LoadMUS_IO()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *SDLCALL Mix_LoadMUS_IO </td>
          <td>(</td>
          <td class="paramtype">SDL_IOStream *</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_bool</td>          <td class="paramname"><span class="paramname"><em>closeio</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a supported audio format into a music object. </p>
<p>SDL_mixer has two separate data structures for audio data. One it calls a "chunk," which is meant to be a file completely decoded into memory up front, and the other it calls "music" which is a file intended to be decoded on demand. Originally, simple formats like uncompressed WAV files were meant to be chunks and compressed things, like MP3s, were meant to be music, and you would stream one thing for a game's music and make repeating sound effects with the chunks.</p>
<p>In modern times, this isn't split by format anymore, and most are interchangeable, so the question is what the app thinks is worth predecoding or not. Chunks might take more memory, but once they are loaded won't need to decode again, whereas music always needs to be decoded on the fly. Also, crucially, there are as many channels for chunks as the app can allocate, but SDL_mixer only offers a single "music" channel.</p>
<p>If <code>closeio</code> is SDL_TRUE, the IOStream will be closed before returning, whether this function succeeds or not. SDL_mixer reads everything it needs from the IOStream during this call in any case.</p>
<p>As a convenience, there is a function to read files from disk without having to deal with SDL_IOStream: <code>Mix_LoadMUS("filename.mp3")</code> will manage those details for you.</p>
<p>This function attempts to guess the file format from incoming data. If the caller knows the format, or wants to force it, it should use <a class="el" href="#a1ba9978eb01d83cc0ad42ec36949781f" title="Load an audio format into a music object, assuming a specific format.">Mix_LoadMUSType_IO()</a> instead.</p>
<p>When done with this music, the app should dispose of it with a call to <a class="el" href="#ac2e103808706941aab379d601a46327b" title="Free a music object.">Mix_FreeMusic()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>an SDL_IOStream that data will be read from. </td></tr>
    <tr><td class="paramname">closeio</td><td>SDL_TRUE to close the SDL_IOStream before returning, SDL_FALSE to leave it open. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new music object, or NULL on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac2e103808706941aab379d601a46327b" title="Free a music object.">Mix_FreeMusic</a> </dd></dl>

</div>
</div>
<a id="a1ba9978eb01d83cc0ad42ec36949781f" name="a1ba9978eb01d83cc0ad42ec36949781f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba9978eb01d83cc0ad42ec36949781f">&#9670;&#160;</a></span>Mix_LoadMUSType_IO()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC <a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *SDLCALL Mix_LoadMUSType_IO </td>
          <td>(</td>
          <td class="paramtype">SDL_IOStream *</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3deb8c84c2e0a1bb970cd496d9e46f46">Mix_MusicType</a></td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_bool</td>          <td class="paramname"><span class="paramname"><em>closeio</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load an audio format into a music object, assuming a specific format. </p>
<p>SDL_mixer has two separate data structures for audio data. One it calls a "chunk," which is meant to be a file completely decoded into memory up front, and the other it calls "music" which is a file intended to be decoded on demand. Originally, simple formats like uncompressed WAV files were meant to be chunks and compressed things, like MP3s, were meant to be music, and you would stream one thing for a game's music and make repeating sound effects with the chunks.</p>
<p>In modern times, this isn't split by format anymore, and most are interchangeable, so the question is what the app thinks is worth predecoding or not. Chunks might take more memory, but once they are loaded won't need to decode again, whereas music always needs to be decoded on the fly. Also, crucially, there are as many channels for chunks as the app can allocate, but SDL_mixer only offers a single "music" channel.</p>
<p>This function loads music data, and lets the application specify the type of music being loaded, which might be useful if SDL_mixer cannot figure it out from the data stream itself.</p>
<p>Currently, the following types are supported:</p>
<ul>
<li><code>MUS_NONE</code> (SDL_mixer should guess, based on the data)</li>
<li><code>MUS_WAV</code> (Microsoft WAV files)</li>
<li><code>MUS_MOD</code> (Various tracker formats)</li>
<li><code>MUS_MID</code> (MIDI files)</li>
<li><code>MUS_OGG</code> (Ogg Vorbis files)</li>
<li><code>MUS_MP3</code> (MP3 files)</li>
<li><code>MUS_FLAC</code> (FLAC files)</li>
<li><code>MUS_OPUS</code> (Opus files)</li>
<li><code>MUS_WAVPACK</code> (WavPack files)</li>
</ul>
<p>If <code>closeio</code> is SDL_TRUE, the IOStream will be closed before returning, whether this function succeeds or not. SDL_mixer reads everything it needs from the IOStream during this call in any case.</p>
<p>As a convenience, there is a function to read files from disk without having to deal with SDL_IOStream: <code>Mix_LoadMUS("filename.mp3")</code> will manage those details for you (but not let you specify the music type explicitly)..</p>
<p>When done with this music, the app should dispose of it with a call to <a class="el" href="#ac2e103808706941aab379d601a46327b" title="Free a music object.">Mix_FreeMusic()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>an SDL_IOStream that data will be read from. </td></tr>
    <tr><td class="paramname">type</td><td>the type of audio data provided by <code>src</code>. </td></tr>
    <tr><td class="paramname">closeio</td><td>SDL_TRUE to close the SDL_IOStream before returning, SDL_FALSE to leave it open. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new music object, or NULL on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac2e103808706941aab379d601a46327b" title="Free a music object.">Mix_FreeMusic</a> </dd></dl>

</div>
</div>
<a id="ad673a76d5638a3a5df0abab5af156d34" name="ad673a76d5638a3a5df0abab5af156d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad673a76d5638a3a5df0abab5af156d34">&#9670;&#160;</a></span>Mix_LoadWAV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC <a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *SDLCALL Mix_LoadWAV </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a supported audio format into a chunk. </p>
<p>SDL_mixer has two separate data structures for audio data. One it calls a "chunk," which is meant to be a file completely decoded into memory up front, and the other it calls "music" which is a file intended to be decoded on demand. Originally, simple formats like uncompressed WAV files were meant to be chunks and compressed things, like MP3s, were meant to be music, and you would stream one thing for a game's music and make repeating sound effects with the chunks.</p>
<p>In modern times, this isn't split by format anymore, and most are interchangeable, so the question is what the app thinks is worth predecoding or not. Chunks might take more memory, but once they are loaded won't need to decode again, whereas music always needs to be decoded on the fly. Also, crucially, there are as many channels for chunks as the app can allocate, but SDL_mixer only offers a single "music" channel.</p>
<p>If you would rather use the abstract SDL_IOStream interface to load data from somewhere other than the filesystem, you can use <a class="el" href="#a623ad2f07078a0b0c9c8758fb3cc8f84" title="Load a supported audio format into a chunk.">Mix_LoadWAV_IO()</a> instead.</p>
<p>When done with a chunk, the app should dispose of it with a call to <a class="el" href="#abf7ae3433476bb4f66acedc6098e5b2d" title="Free an audio chunk.">Mix_FreeChunk()</a>.</p>
<p>Note that before SDL_mixer 3.0.0, this function was a macro that called <a class="el" href="#a623ad2f07078a0b0c9c8758fb3cc8f84" title="Load a supported audio format into a chunk.">Mix_LoadWAV_IO()</a>, creating a IOStream and setting <code>closeio</code> to SDL_TRUE. This macro has since been promoted to a proper API function. Older binaries linked against a newer SDL_mixer will still call Mix_LoadWAV_IO directly, as they are using the macro, which was available since the dawn of time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the filesystem path to load data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new chunk, or NULL on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a623ad2f07078a0b0c9c8758fb3cc8f84" title="Load a supported audio format into a chunk.">Mix_LoadWAV_IO</a> </dd>
<dd>
<a class="el" href="#abf7ae3433476bb4f66acedc6098e5b2d" title="Free an audio chunk.">Mix_FreeChunk</a> </dd></dl>

</div>
</div>
<a id="a623ad2f07078a0b0c9c8758fb3cc8f84" name="a623ad2f07078a0b0c9c8758fb3cc8f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623ad2f07078a0b0c9c8758fb3cc8f84">&#9670;&#160;</a></span>Mix_LoadWAV_IO()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC <a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *SDLCALL Mix_LoadWAV_IO </td>
          <td>(</td>
          <td class="paramtype">SDL_IOStream *</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_bool</td>          <td class="paramname"><span class="paramname"><em>closeio</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a supported audio format into a chunk. </p>
<p>SDL_mixer has two separate data structures for audio data. One it calls a "chunk," which is meant to be a file completely decoded into memory up front, and the other it calls "music" which is a file intended to be decoded on demand. Originally, simple formats like uncompressed WAV files were meant to be chunks and compressed things, like MP3s, were meant to be music, and you would stream one thing for a game's music and make repeating sound effects with the chunks.</p>
<p>In modern times, this isn't split by format anymore, and most are interchangeable, so the question is what the app thinks is worth predecoding or not. Chunks might take more memory, but once they are loaded won't need to decode again, whereas music always needs to be decoded on the fly. Also, crucially, there are as many channels for chunks as the app can allocate, but SDL_mixer only offers a single "music" channel.</p>
<p>If <code>closeio</code> is SDL_TRUE, the IOStream will be closed before returning, whether this function succeeds or not. SDL_mixer reads everything it needs from the IOStream during this call in any case.</p>
<p>There is a separate function (a macro, before SDL_mixer 3.0.0) to read files from disk without having to deal with SDL_IOStream: <code>Mix_LoadWAV("filename.wav")</code> will call this function and manage those details for you.</p>
<p>When done with a chunk, the app should dispose of it with a call to <a class="el" href="#abf7ae3433476bb4f66acedc6098e5b2d" title="Free an audio chunk.">Mix_FreeChunk()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>an SDL_IOStream that data will be read from. </td></tr>
    <tr><td class="paramname">closeio</td><td>SDL_TRUE to close the SDL_IOStream before returning, SDL_FALSE to leave it open. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new chunk, or NULL on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad673a76d5638a3a5df0abab5af156d34" title="Load a supported audio format into a chunk.">Mix_LoadWAV</a> </dd>
<dd>
<a class="el" href="#abf7ae3433476bb4f66acedc6098e5b2d" title="Free an audio chunk.">Mix_FreeChunk</a> </dd></dl>

</div>
</div>
<a id="a5704e4a69605a6d7089d1d21860ea921" name="a5704e4a69605a6d7089d1d21860ea921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5704e4a69605a6d7089d1d21860ea921">&#9670;&#160;</a></span>Mix_MasterVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_MasterVolume </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>volume</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the master volume for all channels. </p>
<p>SDL_mixer keeps a per-channel volume, a per-chunk volume, and a master volume, and considers all three when mixing audio. This function sets the master volume, which is applied to all playing channels when mixing.</p>
<p>The volume must be between 0 (silence) and MIX_MAX_VOLUME (full volume). Note that MIX_MAX_VOLUME is 128. Values greater than MIX_MAX_VOLUME are clamped to MIX_MAX_VOLUME.</p>
<p>Specifying a negative volume will not change the current volume; as such, this can be used to query the current volume without making changes, as this function returns the previous (in this case, still-current) value.</p>
<p>Note that the master volume does not affect any playing music; it is only applied when mixing chunks. Use <a class="el" href="#ab926fc25eab93de464ac7029e2125003" title="Set the volume for the music channel.">Mix_VolumeMusic()</a> for that.\</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>the new volume, between 0 and MIX_MAX_VOLUME, or -1 to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous volume. If the specified volume is -1, this returns the current volume.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="af1d1bde4893345068c002773061ed71c" name="af1d1bde4893345068c002773061ed71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d1bde4893345068c002773061ed71c">&#9670;&#160;</a></span>Mix_ModMusicJumpToOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_ModMusicJumpToOrder </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Jump to a given order in mod music. </p>
<p>This only applies to MOD music formats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if failed or isn't implemented.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a53dfe4fdc126896dc79272f7f3a40350" name="a53dfe4fdc126896dc79272f7f3a40350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53dfe4fdc126896dc79272f7f3a40350">&#9670;&#160;</a></span>Mix_MusicDuration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC double SDLCALL Mix_MusicDuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *</td>          <td class="paramname"><span class="paramname"><em>music</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a music object's duration, in seconds. </p>
<p>To convert to milliseconds, multiply by 1000.0.</p>
<p>If NULL is passed, returns duration of current playing music.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music</td><td>the music object to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>music duration in seconds, or -1.0 on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a23afb407fa3a9766f21d07ea43bee1cd" name="a23afb407fa3a9766f21d07ea43bee1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23afb407fa3a9766f21d07ea43bee1cd">&#9670;&#160;</a></span>Mix_OpenAudio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_OpenAudio </td>
          <td>(</td>
          <td class="paramtype">SDL_AudioDeviceID</td>          <td class="paramname"><span class="paramname"><em>devid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SDL_AudioSpec *</td>          <td class="paramname"><span class="paramname"><em>spec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open an audio device for playback. </p>
<p>An audio device is what generates sound, so the app must open one to make noise.</p>
<p>This function will check if SDL's audio system is initialized, and if not, it will initialize it by calling <code>SDL_Init(SDL_INIT_AUDIO)</code> on your behalf. You are free to (and encouraged to!) initialize it yourself before calling this function, as this gives your program more control over the process.</p>
<p>If you aren't particularly concerned with the specifics of the audio device, and your data isn't in a specific format, you can pass a NULL for the <code>spec</code> parameter and SDL_mixer will choose a reasonable default. SDL_mixer will convert audio data you feed it to the hardware's format behind the scenes.</p>
<p>That being said, if you have control of your audio data and you know its format ahead of time, you may save CPU time by opening the audio device in that exact format so SDL_mixer does not have to spend time converting anything behind the scenes, and can just pass the data straight through to the hardware.</p>
<p>The other reason to care about specific formats: if you plan to touch the mix buffer directly (with Mix_SetPostMix, a registered effect, or Mix_HookMusic), you might have code that expects it to be in a specific format, and you should specify that here.</p>
<p>This function allows you to select specific audio hardware on the system with the <code>devid</code> parameter. If you specify 0, SDL_mixer will choose the best default it can on your behalf (which, in many cases, is exactly what you want anyhow). This is equivalent to specifying <code>SDL_AUDIO_DEVICE_DEFAULT_OUTPUT</code>, but is less wordy. SDL_mixer does not offer a mechanism to determine device IDs to open, but you can use SDL_GetAudioOutputDevices() to get a list of available devices. If you do this, be sure to call <code>SDL_Init(SDL_INIT_AUDIO)</code> first to initialize SDL's audio system!</p>
<p>If this function reports success, you are ready to start making noise! Load some audio data and start playing!</p>
<p>When done with an audio device, probably at the end of the program, the app should close the audio with <a class="el" href="#a2cb071e94923956f4c3ca4d3998669e7" title="Close the mixer, halting all playing audio.">Mix_CloseAudio()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devid</td><td>the device name to open, or 0 for a reasonable default. </td></tr>
    <tr><td class="paramname">spec</td><td>the audio format you'd like SDL_mixer to work in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2cb071e94923956f4c3ca4d3998669e7" title="Close the mixer, halting all playing audio.">Mix_CloseAudio</a> </dd>
<dd>
<a class="el" href="#ab9f5c519bd9cbe0226b42a617b793cb8" title="Find out what the actual audio device parameters are.">Mix_QuerySpec</a> </dd></dl>

</div>
</div>
<a id="a8327a4a060ebc4dc1771db7a3e9d3038" name="a8327a4a060ebc4dc1771db7a3e9d3038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8327a4a060ebc4dc1771db7a3e9d3038">&#9670;&#160;</a></span>Mix_Pause()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC void SDLCALL Mix_Pause </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pause a particular channel. </p>
<p>Pausing a channel will prevent further playback of the assigned chunk but will maintain the chunk's current mixing position. When resumed, this channel will continue to mix the chunk where it left off.</p>
<p>A paused channel can be resumed by calling <a class="el" href="#aa5f6a115fe2ffb8488929d96e8575d70" title="Resume a particular channel.">Mix_Resume()</a>.</p>
<p>A paused channel with an expiration will not expire while paused (the expiration countdown will be adjusted once resumed).</p>
<p>It is legal to halt a paused channel. Playing a new chunk on a paused channel will replace the current chunk and unpause the channel.</p>
<p>Specifying a channel of -1 will pause <em>all</em> channels. Any music is unaffected.</p>
<p>You may not specify MAX_CHANNEL_POST for a channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to pause, or -1 to pause all channels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a93a28d4294c7054944fced8b831f0b6b" name="a93a28d4294c7054944fced8b831f0b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a28d4294c7054944fced8b831f0b6b">&#9670;&#160;</a></span>Mix_PauseAudio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC void SDLCALL Mix_PauseAudio </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pause_on</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suspend or resume the whole audio output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pause_on</td><td>1 to pause audio output, or 0 to resume.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a90c6066d45d6376b1c570fdc83622cc2" name="a90c6066d45d6376b1c570fdc83622cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c6066d45d6376b1c570fdc83622cc2">&#9670;&#160;</a></span>Mix_Paused()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_Paused </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether a particular channel is paused. </p>
<p>If an invalid channel is specified, this function returns zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to query, or -1 to query all channels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if channel paused, 0 otherwise. If <code>channel</code> is -1, returns the number of paused channels.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a6366b72369e1217ed7f45d2c0d5acb1d" name="a6366b72369e1217ed7f45d2c0d5acb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6366b72369e1217ed7f45d2c0d5acb1d">&#9670;&#160;</a></span>Mix_PausedMusic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_PausedMusic </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether the music stream is paused. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if music is paused, 0 otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#abe25a71474eae91d3ad725eb4ad8ed39" title="Pause the music stream.">Mix_PauseMusic</a> </dd>
<dd>
<a class="el" href="#aa45edeb5e03075593c4567e197565979" title="Resume the music stream.">Mix_ResumeMusic</a> </dd></dl>

</div>
</div>
<a id="acb401349586584fd1635b692732479c2" name="acb401349586584fd1635b692732479c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb401349586584fd1635b692732479c2">&#9670;&#160;</a></span>Mix_PauseGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_PauseGroup </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pause playing of a group of channels by arbitrary tag. </p>
<p>Pausing a channel will prevent further playback of the assigned chunk but will maintain the chunk's current mixing position. When resumed, this channel will continue to mix the chunk where it left off.</p>
<p>A paused channel can be resumed by calling <a class="el" href="#aa5f6a115fe2ffb8488929d96e8575d70" title="Resume a particular channel.">Mix_Resume()</a> or <a class="el" href="#aa5b6ac6a764dffe3005ea16341d9d044" title="Resume playing of a group of channels by arbitrary tag.">Mix_ResumeGroup()</a>.</p>
<p>A paused channel with an expiration will not expire while paused (the expiration countdown will be adjusted once resumed).</p>
<p>A tag is an arbitrary number that can be assigned to several mixer channels, to form groups of channels.</p>
<p>The default tag for a channel is -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>an arbitrary value, assigned to channels, to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero, whether any channels were halted or not.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="abe25a71474eae91d3ad725eb4ad8ed39" name="abe25a71474eae91d3ad725eb4ad8ed39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe25a71474eae91d3ad725eb4ad8ed39">&#9670;&#160;</a></span>Mix_PauseMusic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC void SDLCALL Mix_PauseMusic </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pause the music stream. </p>
<p>Pausing the music stream will prevent further playback of the assigned music object, but will maintain the object's current mixing position. When resumed, this channel will continue to mix the music where it left off.</p>
<p>Paused music can be resumed by calling <a class="el" href="#aa45edeb5e03075593c4567e197565979" title="Resume the music stream.">Mix_ResumeMusic()</a>.</p>
<p>It is legal to halt paused music. Playing a new music object when music is paused will replace the current music and unpause the music stream.</p>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="af9f0143230493220f052f50e1cabc070" name="af9f0143230493220f052f50e1cabc070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f0143230493220f052f50e1cabc070">&#9670;&#160;</a></span>Mix_PlayChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_PlayChannel </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *</td>          <td class="paramname"><span class="paramname"><em>chunk</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Play an audio chunk on a specific channel. </p>
<p>If the specified channel is -1, play on the first free channel (and return -1 without playing anything new if no free channel was available).</p>
<p>If a specific channel was requested, and there is a chunk already playing there, that chunk will be halted and the new chunk will take its place.</p>
<p>If <code>loops</code> is greater than zero, loop the sound that many times. If <code>loops</code> is -1, loop "infinitely" (~65000 times).</p>
<p>Note that before SDL_mixer 3.0.0, this function was a macro that called <a class="el" href="#a9e7e5bb8d3dbd3539eb3d032589fc624" title="Play an audio chunk on a specific channel for a maximum time.">Mix_PlayChannelTimed()</a> with a fourth parameter ("ticks") of -1. This function still does the same thing, but promotes it to a proper API function. Older binaries linked against a newer SDL_mixer will still call Mix_PlayChannelTimed directly, as they are using the macro, which was available since the dawn of time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel on which to play the new chunk. </td></tr>
    <tr><td class="paramname">chunk</td><td>the new chunk to play. </td></tr>
    <tr><td class="paramname">loops</td><td>the number of times the chunk should loop, -1 to loop (not actually) infinitely. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>which channel was used to play the sound, or -1 if sound could not be played.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0 </dd></dl>

</div>
</div>
<a id="a9e7e5bb8d3dbd3539eb3d032589fc624" name="a9e7e5bb8d3dbd3539eb3d032589fc624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7e5bb8d3dbd3539eb3d032589fc624">&#9670;&#160;</a></span>Mix_PlayChannelTimed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_PlayChannelTimed </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *</td>          <td class="paramname"><span class="paramname"><em>chunk</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>loops</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ticks</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Play an audio chunk on a specific channel for a maximum time. </p>
<p>If the specified channel is -1, play on the first free channel (and return -1 without playing anything new if no free channel was available).</p>
<p>If a specific channel was requested, and there is a chunk already playing there, that chunk will be halted and the new chunk will take its place.</p>
<p>If <code>loops</code> is greater than zero, loop the sound that many times. If <code>loops</code> is -1, loop "infinitely" (~65000 times).</p>
<p><code>ticks</code> specifies the maximum number of milliseconds to play this chunk before halting it. If you want the chunk to play until all data has been mixed, specify -1.</p>
<p>Note that this function does not block for the number of ticks requested; it just schedules the chunk to play and notes the maximum for the mixer to manage later, and returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel on which to play the new chunk. </td></tr>
    <tr><td class="paramname">chunk</td><td>the new chunk to play. </td></tr>
    <tr><td class="paramname">loops</td><td>the number of times the chunk should loop, -1 to loop (not actually) infinitely. </td></tr>
    <tr><td class="paramname">ticks</td><td>the maximum number of milliseconds of this chunk to mix for playback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>which channel was used to play the sound, or -1 if sound could not be played.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a2762f72d43ec5332250311a9887a8998" name="a2762f72d43ec5332250311a9887a8998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2762f72d43ec5332250311a9887a8998">&#9670;&#160;</a></span>Mix_Playing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_Playing </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the playing status of a specific channel. </p>
<p>If the channel is currently playing, this function returns 1. Otherwise it returns 0.</p>
<p>If the specified channel is -1, all channels are checked, and this function returns the number of channels currently playing.</p>
<p>You may not specify MAX_CHANNEL_POST for a channel.</p>
<p>Paused channels are treated as playing, even though they are not currently making forward progress in mixing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if channel is playing, zero otherwise. If <code>channel</code> is -1, return the total number of channel playings.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="aa325c04b56dc4fb7909b5636a12a9f67" name="aa325c04b56dc4fb7909b5636a12a9f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa325c04b56dc4fb7909b5636a12a9f67">&#9670;&#160;</a></span>Mix_PlayingMusic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_PlayingMusic </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the playing status of the music stream. </p>
<p>If music is currently playing, this function returns 1. Otherwise it returns 0.</p>
<p>Paused music is treated as playing, even though it is not currently making forward progress in mixing.</p>
<dl class="section return"><dt>Returns</dt><dd>non-zero if music is playing, zero otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a215ea5402d7da6d73a53b408d33b06b3" name="a215ea5402d7da6d73a53b408d33b06b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215ea5402d7da6d73a53b408d33b06b3">&#9670;&#160;</a></span>Mix_PlayMusic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_PlayMusic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *</td>          <td class="paramname"><span class="paramname"><em>music</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Play a new music object. </p>
<p>This will schedule the music object to begin mixing for playback.</p>
<p>There is only ever one music object playing at a time; if this is called when another music object is playing, the currently-playing music is halted and the new music will replace it.</p>
<p>Please note that if the currently-playing music is in the process of fading out (via <a class="el" href="#aff8cc2e99284bf7268b1ee62b86b5367" title="Halt the music stream after fading it out for a specified time.">Mix_FadeOutMusic()</a>), this function will <em>block</em> until the fade completes. If you need to avoid this, be sure to call <a class="el" href="#a2b2bc73786ee25eddb63208751baba76" title="Halt playing of the music stream.">Mix_HaltMusic()</a> before starting new music.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music</td><td>the new music object to schedule for mixing. </td></tr>
    <tr><td class="paramname">loops</td><td>the number of loops to play the music for (0 means "play once
             and stop"). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on success, -1 on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="ab9f5c519bd9cbe0226b42a617b793cb8" name="ab9f5c519bd9cbe0226b42a617b793cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f5c519bd9cbe0226b42a617b793cb8">&#9670;&#160;</a></span>Mix_QuerySpec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_QuerySpec </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>frequency</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *</td>          <td class="paramname"><span class="paramname"><em>format</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>channels</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find out what the actual audio device parameters are. </p>
<p>Note this is only important if the app intends to touch the audio buffers being sent to the hardware directly. If an app just wants to play audio files and let SDL_mixer handle the low-level details, this function can probably be ignored.</p>
<p>If the audio device is not opened, this function will return 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency</td><td>On return, will be filled with the audio device's frequency in Hz. </td></tr>
    <tr><td class="paramname">format</td><td>On return, will be filled with the audio device's format. </td></tr>
    <tr><td class="paramname">channels</td><td>On return, will be filled with the audio device's channel count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the audio device has been opened, 0 otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a23afb407fa3a9766f21d07ea43bee1cd" title="Open an audio device for playback.">Mix_OpenAudio</a> </dd></dl>

</div>
</div>
<a id="a1e8da2bdfc6512b766235a3e9670462d" name="a1e8da2bdfc6512b766235a3e9670462d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8da2bdfc6512b766235a3e9670462d">&#9670;&#160;</a></span>Mix_QuickLoad_RAW()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC <a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *SDLCALL Mix_QuickLoad_RAW </td>
          <td>(</td>
          <td class="paramtype">Uint8 *</td>          <td class="paramname"><span class="paramname"><em>mem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a raw audio data from memory as quickly as possible. </p>
<p>The audio data MUST be in the exact same format as the audio device. This function will not attempt to convert it, or even verify it's in the right format.</p>
<p>If this function is successful, the provided memory buffer must remain available until <a class="el" href="#abf7ae3433476bb4f66acedc6098e5b2d" title="Free an audio chunk.">Mix_FreeChunk()</a> is called on the returned chunk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>memory buffer containing raw PCM data. </td></tr>
    <tr><td class="paramname">len</td><td>length of buffer pointed to by <code>mem</code>, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new chunk, or NULL on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#abf7ae3433476bb4f66acedc6098e5b2d" title="Free an audio chunk.">Mix_FreeChunk</a> </dd></dl>

</div>
</div>
<a id="a6a2833e2d174d29d32ac514574ee8866" name="a6a2833e2d174d29d32ac514574ee8866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2833e2d174d29d32ac514574ee8866">&#9670;&#160;</a></span>Mix_QuickLoad_WAV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC <a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *SDLCALL Mix_QuickLoad_WAV </td>
          <td>(</td>
          <td class="paramtype">Uint8 *</td>          <td class="paramname"><span class="paramname"><em>mem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a WAV file from memory as quickly as possible. </p>
<p>Unlike Mix_LoadWAV_IO, this function has several requirements, and unless you control all your audio data and know what you're doing, you should consider this function unsafe and not use it.</p>
<ul>
<li>The provided audio data MUST be in Microsoft WAV format.</li>
<li>The provided audio data shouldn't use any strange WAV extensions.</li>
<li>The audio data MUST be in the exact same format as the audio device. This function will not attempt to convert it, or even verify it's in the right format.</li>
<li>The audio data must be valid; this function does not know the size of the memory buffer, so if the WAV data is corrupted, it can read past the end of the buffer, causing a crash.</li>
<li>The audio data must live at least as long as the returned <a class="el" href="struct_mix___chunk.html" title="The internal format for an audio chunk.">Mix_Chunk</a>, because SDL_mixer will use that data directly and not make a copy of it.</li>
</ul>
<p>This function will do NO error checking! Be extremely careful here!</p>
<p>(Seriously, use Mix_LoadWAV_IO instead.)</p>
<p>If this function is successful, the provided memory buffer must remain available until <a class="el" href="#abf7ae3433476bb4f66acedc6098e5b2d" title="Free an audio chunk.">Mix_FreeChunk()</a> is called on the returned chunk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>memory buffer containing of a WAV file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new chunk, or NULL on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a623ad2f07078a0b0c9c8758fb3cc8f84" title="Load a supported audio format into a chunk.">Mix_LoadWAV_IO</a> </dd>
<dd>
<a class="el" href="#abf7ae3433476bb4f66acedc6098e5b2d" title="Free an audio chunk.">Mix_FreeChunk</a> </dd></dl>

</div>
</div>
<a id="a136e5586b53fe0e3e752e2174bd7bb70" name="a136e5586b53fe0e3e752e2174bd7bb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136e5586b53fe0e3e752e2174bd7bb70">&#9670;&#160;</a></span>Mix_Quit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC void SDLCALL Mix_Quit </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deinitialize SDL_mixer. </p>
<p>This should be the last function you call in SDL_mixer, after freeing all other resources and closing all audio devices. This will unload any shared libraries it is using for various codecs.</p>
<p>After this call, a call to Mix_Init(0) will return 0 (no codecs loaded).</p>
<p>You can safely call <a class="el" href="#a71a389ff8fb5e4af34d0951e73d05995" title="Initialize SDL_mixer.">Mix_Init()</a> to reload various codec support after this call.</p>
<p>Unlike other SDL satellite libraries, calls to Mix_Init do not stack; a single call to <a class="el" href="#a136e5586b53fe0e3e752e2174bd7bb70" title="Deinitialize SDL_mixer.">Mix_Quit()</a> will deinitialize everything and does not have to be paired with a matching Mix_Init call. For that reason, it's considered best practices to have a single Mix_Init and Mix_Quit call in your program. While this isn't required, be aware of the risks of deviating from that behavior.</p>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a71a389ff8fb5e4af34d0951e73d05995" title="Initialize SDL_mixer.">Mix_Init</a> </dd></dl>

</div>
</div>
<a id="aa3843504b9dfb94b22d4f74721adebf8" name="aa3843504b9dfb94b22d4f74721adebf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3843504b9dfb94b22d4f74721adebf8">&#9670;&#160;</a></span>Mix_RegisterEffect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_RegisterEffect </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>chan</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aed80ffef737d37eefc7354e0ebff8c1b">Mix_EffectFunc_t</a></td>          <td class="paramname"><span class="paramname"><em>f</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac568739ba54c90964224a2b6365f61c7">Mix_EffectDone_t</a></td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a special effect function. </p>
<p>At mixing time, the channel data is copied into a buffer and passed through each registered effect function. After it passes through all the functions, it is mixed into the final output stream. The copy to buffer is performed once, then each effect function performs on the output of the previous effect. Understand that this extra copy to a buffer is not performed if there are no effects registered for a given chunk, which saves CPU cycles, and any given effect will be extra cycles, too, so it is crucial that your code run fast. Also note that the data that your function is given is in the format of the sound device, and not the format you gave to <a class="el" href="#a23afb407fa3a9766f21d07ea43bee1cd" title="Open an audio device for playback.">Mix_OpenAudio()</a>, although they may in reality be the same. This is an unfortunate but necessary speed concern. Use <a class="el" href="#ab9f5c519bd9cbe0226b42a617b793cb8" title="Find out what the actual audio device parameters are.">Mix_QuerySpec()</a> to determine if you can handle the data before you register your effect, and take appropriate actions.</p>
<p>You may also specify a callback (Mix_EffectDone_t) that is called when the channel finishes playing. This gives you a more fine-grained control than <a class="el" href="#a8bb79c6f792464428d51b6aba1088b77" title="Set a callback that runs when a channel has finished playing.">Mix_ChannelFinished()</a>, in case you need to free effect-specific resources, etc. If you don't need this, you can specify NULL.</p>
<p>You may set the callbacks before or after calling <a class="el" href="#af9f0143230493220f052f50e1cabc070" title="Play an audio chunk on a specific channel.">Mix_PlayChannel()</a>.</p>
<p>Things like <a class="el" href="#a896c0ac1043249dfbf1bc758297f54f2" title="Set the panning of a channel.">Mix_SetPanning()</a> are just internal special effect functions, so if you are using that, you've already incurred the overhead of a copy to a separate buffer, and that these effects will be in the queue with any functions you've registered. The list of registered effects for a channel is reset when a chunk finishes playing, so you need to explicitly set them with each call to Mix_PlayChannel*().</p>
<p>You may also register a special effect function that is to be run after final mixing occurs. The rules for these callbacks are identical to those in Mix_RegisterEffect, but they are run after all the channels and the music have been mixed into a single stream, whereas channel-specific effects run on a given channel before any other mixing occurs. These global effect callbacks are call "posteffects". Posteffects only have their Mix_EffectDone_t function called when they are unregistered (since the main output stream is never "done" in the same sense as a channel). You must unregister them manually when you've had enough. Your callback will be told that the channel being mixed is <code>MIX_CHANNEL_POST</code> if the processing is considered a posteffect.</p>
<p>After all these effects have finished processing, the callback registered through <a class="el" href="#a7dc4ec0f09fd676d9d7569550d866ca7" title="Set a function that is called after all mixing is performed.">Mix_SetPostMix()</a> runs, and then the stream goes to the audio device.</p>
<p>DO NOT EVER call SDL_LockAudio() from your callback function! You are already running in the audio thread and the lock is already held!</p>
<p>Note that unlike most SDL and SDL_mixer functions, this function returns zero if there's an error, not on success. We apologize for the API design inconsistency here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel to register an effect to, or MIX_CHANNEL_POST. </td></tr>
    <tr><td class="paramname">f</td><td>effect the callback to run when more of this channel is to be mixed. </td></tr>
    <tr><td class="paramname">d</td><td>effect done callback </td></tr>
    <tr><td class="paramname">arg</td><td>argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if error (no such channel), nonzero if added. Error messages can be retrieved from <a class="el" href="#ab29aa52963e2c1dd92888629c810c74f" title="Get last SDL_mixer error.">Mix_GetError()</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="af5d97b94207796ae479f7599a0b3a89e" name="af5d97b94207796ae479f7599a0b3a89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d97b94207796ae479f7599a0b3a89e">&#9670;&#160;</a></span>Mix_ReserveChannels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_ReserveChannels </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve the first channels for the application. </p>
<p>While SDL_mixer will use up to the number of channels allocated by <a class="el" href="#a3bb24eade448b0c5515f9d402d935924" title="Dynamically change the number of channels managed by the mixer.">Mix_AllocateChannels()</a>, this sets channels aside that will not be available when calling Mix_PlayChannel with a channel of -1 (play on the first unused channel). In this case, SDL_mixer will treat reserved channels as "used" whether anything is playing on them at the moment or not.</p>
<p>This is useful if you've budgeted some channels for dedicated audio and the rest are just used as they are available.</p>
<p>Calling this function will set channels 0 to <code>n - 1</code> to be reserved. This will not change channel allocations. The number of reserved channels will be clamped to the current number allocated.</p>
<p>By default, no channels are reserved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>number of channels to reserve, starting at index zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of reserved channels.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="aa5f6a115fe2ffb8488929d96e8575d70" name="aa5f6a115fe2ffb8488929d96e8575d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f6a115fe2ffb8488929d96e8575d70">&#9670;&#160;</a></span>Mix_Resume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC void SDLCALL Mix_Resume </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resume a particular channel. </p>
<p>It is legal to resume an unpaused or invalid channel; it causes no effect and reports no error.</p>
<p>If the paused channel has an expiration, its expiration countdown resumes now, as well.</p>
<p>Specifying a channel of -1 will resume <em>all</em> paused channels. Any music is unaffected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to resume, or -1 to resume all paused channels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="aa5b6ac6a764dffe3005ea16341d9d044" name="aa5b6ac6a764dffe3005ea16341d9d044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b6ac6a764dffe3005ea16341d9d044">&#9670;&#160;</a></span>Mix_ResumeGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_ResumeGroup </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resume playing of a group of channels by arbitrary tag. </p>
<p>It is legal to resume an unpaused or invalid channel; it causes no effect and reports no error.</p>
<p>If the paused channel has an expiration, its expiration countdown resumes now, as well.</p>
<p>A tag is an arbitrary number that can be assigned to several mixer channels, to form groups of channels.</p>
<p>The default tag for a channel is -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>an arbitrary value, assigned to channels, to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero, whether any channels were resumed or not.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="aa45edeb5e03075593c4567e197565979" name="aa45edeb5e03075593c4567e197565979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45edeb5e03075593c4567e197565979">&#9670;&#160;</a></span>Mix_ResumeMusic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC void SDLCALL Mix_ResumeMusic </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resume the music stream. </p>
<p>It is legal to resume an unpaused music stream; it causes no effect and reports no error.</p>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a24f8498924c913883808b0a3ac7f4ebc" name="a24f8498924c913883808b0a3ac7f4ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f8498924c913883808b0a3ac7f4ebc">&#9670;&#160;</a></span>Mix_RewindMusic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC void SDLCALL Mix_RewindMusic </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewind the music stream. </p>
<p>This causes the currently-playing music to start mixing from the beginning of the music, as if it were just started.</p>
<p>It's a legal no-op to rewind the music stream when not playing.</p>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a36a244386902034964e4c5f5bcfef808" name="a36a244386902034964e4c5f5bcfef808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a244386902034964e4c5f5bcfef808">&#9670;&#160;</a></span>Mix_SetDistance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_SetDistance </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8</td>          <td class="paramname"><span class="paramname"><em>distance</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the "distance" of a channel. </p>
<p><code>distance</code> is an integer from 0 to 255 that specifies the location of the sound in relation to the listener. Distance 0 is overlapping the listener, and 255 is as far away as possible. A distance of 255 does not guarantee silence; in such a case, you might want to try changing the chunk's volume, or just cull the sample from the mixing process with <a class="el" href="#a369f1cc25e69d0dc2a6f652109de9683" title="Halt playing of a particular channel.">Mix_HaltChannel()</a>. For efficiency, the precision of this effect may be limited (distances 1 through 7 might all produce the same effect, 8 through 15 are equal, etc). (distance) is an integer between 0 and 255 that specifies the space between the sound and the listener. The larger the number, the further away the sound is. Setting the distance to 0 unregisters this effect, since the data would be unchanged. If you need more precise positional audio, consider using OpenAL for spatialized effects instead of SDL_mixer. This is only meant to be a basic effect for simple "3D" games.</p>
<p>Setting the channel to MIX_CHANNEL_POST registers this as a posteffect, and the distance attenuation will be done to the final mixed stream before passing it on to the audio device.</p>
<p>This uses the <a class="el" href="#aa3843504b9dfb94b22d4f74721adebf8" title="Register a special effect function.">Mix_RegisterEffect()</a> API internally.</p>
<p>Note that unlike most SDL and SDL_mixer functions, this function returns zero if there's an error, not on success. We apologize for the API design inconsistency here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The mixer channel to attenuate, or MIX_CHANNEL_POST. </td></tr>
    <tr><td class="paramname">distance</td><td>distance; 0 is the listener, 255 is maxiumum distance away. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if error (no such channel or <a class="el" href="#aa3843504b9dfb94b22d4f74721adebf8" title="Register a special effect function.">Mix_RegisterEffect()</a> fails), nonzero if position effect is enabled. Error messages can be retrieved from <a class="el" href="#ab29aa52963e2c1dd92888629c810c74f" title="Get last SDL_mixer error.">Mix_GetError()</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a06ae6e530b2bda61f772c74e374e70af" name="a06ae6e530b2bda61f772c74e374e70af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ae6e530b2bda61f772c74e374e70af">&#9670;&#160;</a></span>Mix_SetMusicCMD()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_SetMusicCMD </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>command</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run an external command as the music stream. </p>
<p>This halts any currently-playing music, and next time the music stream is played, SDL_mixer will spawn a process using the command line specified in <code>command</code>. This command is not subject to shell expansion, and beyond some basic splitting up of arguments, is passed to execvp() on most platforms, not system().</p>
<p>The command is responsible for generating sound; it is NOT mixed by SDL_mixer! SDL_mixer will kill the child process if asked to halt the music, but otherwise does not have any control over what the process does.</p>
<p>You are strongly encouraged not to use this function without an extremely good reason.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>command </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 on error</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="adfa5bcba7e8d583f576180af0ff5a732" name="adfa5bcba7e8d583f576180af0ff5a732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa5bcba7e8d583f576180af0ff5a732">&#9670;&#160;</a></span>Mix_SetMusicPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_SetMusicPosition </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>position</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current position in the music stream, in seconds. </p>
<p>To convert from milliseconds, divide by 1000.0.</p>
<p>This function is only implemented for MOD music formats (set pattern order number) and for WAV, OGG, FLAC, MP3, and MODPLUG music at the moment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>the new position, in seconds (as a double). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if it failed or not implemented.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a896c0ac1043249dfbf1bc758297f54f2" name="a896c0ac1043249dfbf1bc758297f54f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896c0ac1043249dfbf1bc758297f54f2">&#9670;&#160;</a></span>Mix_SetPanning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_SetPanning </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8</td>          <td class="paramname"><span class="paramname"><em>left</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the panning of a channel. </p>
<p>The left and right channels are specified as integers between 0 and 255, quietest to loudest, respectively.</p>
<p>Technically, this is just individual volume control for a sample with two (stereo) channels, so it can be used for more than just panning. If you want real panning, call it like this:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a896c0ac1043249dfbf1bc758297f54f2">Mix_SetPanning</a>(channel, left, 255 - left);</div>
<div class="ttc" id="a_s_d_l__mixer_8h_html_a896c0ac1043249dfbf1bc758297f54f2"><div class="ttname"><a href="#a896c0ac1043249dfbf1bc758297f54f2">Mix_SetPanning</a></div><div class="ttdeci">DECLSPEC int SDLCALL Mix_SetPanning(int channel, Uint8 left, Uint8 right)</div><div class="ttdoc">Set the panning of a channel.</div></div>
</div><!-- fragment --><p>Setting <code>channel</code> to MIX_CHANNEL_POST registers this as a posteffect, and the panning will be done to the final mixed stream before passing it on to the audio device.</p>
<p>This uses the <a class="el" href="#aa3843504b9dfb94b22d4f74721adebf8" title="Register a special effect function.">Mix_RegisterEffect()</a> API internally, and returns without registering the effect function if the audio device is not configured for stereo output. Setting both <code>left</code> and <code>right</code> to 255 causes this effect to be unregistered, since that is the data's normal state.</p>
<p>Note that an audio device in mono mode is a no-op, but this call will return successful in that case. Error messages can be retrieved from <a class="el" href="#ab29aa52963e2c1dd92888629c810c74f" title="Get last SDL_mixer error.">Mix_GetError()</a>.</p>
<p>Note that unlike most SDL and SDL_mixer functions, this function returns zero if there's an error, not on success. We apologize for the API design inconsistency here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The mixer channel to pan or MIX_CHANNEL_POST. </td></tr>
    <tr><td class="paramname">left</td><td>Volume of stereo left channel, 0 is silence, 255 is full volume. </td></tr>
    <tr><td class="paramname">right</td><td>Volume of stereo right channel, 0 is silence, 255 is full volume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if error (no such channel or <a class="el" href="#aa3843504b9dfb94b22d4f74721adebf8" title="Register a special effect function.">Mix_RegisterEffect()</a> fails), nonzero if panning effect enabled.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3708de5fc6fc191bb691e972f257a63d" title="Set the position of a channel.">Mix_SetPosition</a> </dd>
<dd>
<a class="el" href="#a36a244386902034964e4c5f5bcfef808" title="Set the &quot;distance&quot; of a channel.">Mix_SetDistance</a> </dd></dl>

</div>
</div>
<a id="a3708de5fc6fc191bb691e972f257a63d" name="a3708de5fc6fc191bb691e972f257a63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3708de5fc6fc191bb691e972f257a63d">&#9670;&#160;</a></span>Mix_SetPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_SetPosition </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sint16</td>          <td class="paramname"><span class="paramname"><em>angle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8</td>          <td class="paramname"><span class="paramname"><em>distance</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the position of a channel. </p>
<p><code>angle</code> is an integer from 0 to 360, that specifies the location of the sound in relation to the listener. <code>angle</code> will be reduced as necessary (540 becomes 180 degrees, -100 becomes 260). Angle 0 is due north, and rotates clockwise as the value increases. For efficiency, the precision of this effect may be limited (angles 1 through 7 might all produce the same effect, 8 through 15 are equal, etc). <code>distance</code> is an integer between 0 and 255 that specifies the space between the sound and the listener. The larger the number, the further away the sound is. Using 255 does not guarantee that the channel will be removed from the mixing process or be completely silent. For efficiency, the precision of this effect may be limited (distance 0 through 5 might all produce the same effect, 6 through 10 are equal, etc). Setting <code>angle</code> and <code>distance</code> to 0 unregisters this effect, since the data would be unchanged.</p>
<p>If you need more precise positional audio, consider using OpenAL for spatialized effects instead of SDL_mixer. This is only meant to be a basic effect for simple "3D" games.</p>
<p>If the audio device is configured for mono output, then you won't get any effectiveness from the angle; however, distance attenuation on the channel will still occur. While this effect will function with stereo voices, it makes more sense to use voices with only one channel of sound, so when they are mixed through this effect, the positioning will sound correct. You can convert them to mono through SDL before giving them to the mixer in the first place if you like.</p>
<p>Setting the channel to MIX_CHANNEL_POST registers this as a posteffect, and the positioning will be done to the final mixed stream before passing it on to the audio device.</p>
<p>This is a convenience wrapper over <a class="el" href="#a36a244386902034964e4c5f5bcfef808" title="Set the &quot;distance&quot; of a channel.">Mix_SetDistance()</a> and <a class="el" href="#a896c0ac1043249dfbf1bc758297f54f2" title="Set the panning of a channel.">Mix_SetPanning()</a>.</p>
<p>Note that unlike most SDL and SDL_mixer functions, this function returns zero if there's an error, not on success. We apologize for the API design inconsistency here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The mixer channel to position, or MIX_CHANNEL_POST. </td></tr>
    <tr><td class="paramname">angle</td><td>angle, in degrees. North is 0, and goes clockwise. </td></tr>
    <tr><td class="paramname">distance</td><td>distance; 0 is the listener, 255 is maxiumum distance away. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if error (no such channel or <a class="el" href="#aa3843504b9dfb94b22d4f74721adebf8" title="Register a special effect function.">Mix_RegisterEffect()</a> fails), nonzero if position effect is enabled. Error messages can be retrieved from <a class="el" href="#ab29aa52963e2c1dd92888629c810c74f" title="Get last SDL_mixer error.">Mix_GetError()</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a7dc4ec0f09fd676d9d7569550d866ca7" name="a7dc4ec0f09fd676d9d7569550d866ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc4ec0f09fd676d9d7569550d866ca7">&#9670;&#160;</a></span>Mix_SetPostMix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC void SDLCALL Mix_SetPostMix </td>
          <td>(</td>
          <td class="paramtype">void(SDLCALL *mix_func)(void *udata, Uint8 *stream, int len)</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a function that is called after all mixing is performed. </p>
<p>This can be used to provide real-time visual display of the audio stream or add a custom mixer filter for the stream data.</p>
<p>The callback will fire every time SDL_mixer is ready to supply more data to the audio device, after it has finished all its mixing work. This runs inside an SDL audio callback, so it's important that the callback return quickly, or there could be problems in the audio playback.</p>
<p>The data provided to the callback is in the format that the audio device was opened in, and it represents the exact waveform SDL_mixer has mixed from all playing chunks and music for playback. You are allowed to modify the data, but it cannot be resized (so you can't add a reverb effect that goes past the end of the buffer without saving some state between runs to add it into the next callback, or resample the buffer to a smaller size to speed it up, etc).</p>
<p>The <code>arg</code> pointer supplied here is passed to the callback as-is, for whatever the callback might want to do with it (keep track of some ongoing state, settings, etc).</p>
<p>Passing a NULL callback disables the post-mix callback until such a time as a new one callback is set.</p>
<p>There is only one callback available. If you need to mix multiple inputs, be prepared to handle them from a single function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mix_func</td><td>the callback function to become the new post-mix callback. </td></tr>
    <tr><td class="paramname">arg</td><td>a pointer that is passed, untouched, to the callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9c7889c7e4fd6c846e6ddf68a6b8eb12" title="Add your own music player or additional mixer function.">Mix_HookMusic</a> </dd></dl>

</div>
</div>
<a id="ae26962e9d1fe6c9bdf249237433bf109" name="ae26962e9d1fe6c9bdf249237433bf109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26962e9d1fe6c9bdf249237433bf109">&#9670;&#160;</a></span>Mix_SetReverseStereo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_SetReverseStereo </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flip</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cause a channel to reverse its stereo. </p>
<p>This is handy if the user has his speakers hooked up backwards, or you would like to have a trippy sound effect.</p>
<p>Calling this function with <code>flip</code> set to non-zero reverses the chunks's usual channels. If <code>flip</code> is zero, the effect is unregistered.</p>
<p>This uses the <a class="el" href="#aa3843504b9dfb94b22d4f74721adebf8" title="Register a special effect function.">Mix_RegisterEffect()</a> API internally, and thus is probably more CPU intensive than having the user just plug in his speakers correctly. <a class="el" href="#ae26962e9d1fe6c9bdf249237433bf109" title="Cause a channel to reverse its stereo.">Mix_SetReverseStereo()</a> returns without registering the effect function if the audio device is not configured for stereo output.</p>
<p>If you specify MIX_CHANNEL_POST for <code>channel</code>, then this effect is used on the final mixed stream before sending it on to the audio device (a posteffect).</p>
<p>Note that unlike most SDL and SDL_mixer functions, this function returns zero if there's an error, not on success. We apologize for the API design inconsistency here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The mixer channel to reverse, or MIX_CHANNEL_POST. </td></tr>
    <tr><td class="paramname">flip</td><td>non-zero to reverse stereo, zero to disable this effect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if error (no such channel or <a class="el" href="#aa3843504b9dfb94b22d4f74721adebf8" title="Register a special effect function.">Mix_RegisterEffect()</a> fails), nonzero if reversing effect is enabled. Note that an audio device in mono mode is a no-op, but this call will return successful in that case. Error messages can be retrieved from <a class="el" href="#ab29aa52963e2c1dd92888629c810c74f" title="Get last SDL_mixer error.">Mix_GetError()</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="aa503e9b83c9fbf14496d93947568de8f" name="aa503e9b83c9fbf14496d93947568de8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa503e9b83c9fbf14496d93947568de8f">&#9670;&#160;</a></span>Mix_SetSoundFonts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_SetSoundFonts </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>paths</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set SoundFonts paths to use by supported MIDI backends. </p>
<p>You may specify multiple paths in a single string by separating them with semicolons; they will be searched in the order listed.</p>
<p>This function replaces any previously-specified paths.</p>
<p>Passing a NULL path will remove any previously-specified paths.</p>
<p>Note that unlike most SDL and SDL_mixer functions, this function returns zero if there's an error, not on success. We apologize for the API design inconsistency here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paths</td><td>Paths on the filesystem where SoundFonts are available, separated by semicolons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 on error (out of memory).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="af78d8fcc7feb777a2d3b1e94cb178fd1" name="af78d8fcc7feb777a2d3b1e94cb178fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78d8fcc7feb777a2d3b1e94cb178fd1">&#9670;&#160;</a></span>Mix_SetSynchroValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_SetSynchroValue </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function does nothing, do not use. </p>
<p>This was probably meant to expose a feature, but no codecs support it, so it only remains for binary compatibility.</p>
<p>Calling this function is a legal no-op that returns -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>this parameter is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="acd9d1061909d9b80853034120735fd57" name="acd9d1061909d9b80853034120735fd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9d1061909d9b80853034120735fd57">&#9670;&#160;</a></span>Mix_SetTimidityCfg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_SetTimidityCfg </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set full path of the Timidity config file. </p>
<p>For example, "/etc/timidity.cfg"</p>
<p>This is obviously only useful if SDL_mixer is using Timidity internally to play MIDI files.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>path to a Timidity config file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 on error</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a312db16e22c5fd8788bb695841d30456" name="a312db16e22c5fd8788bb695841d30456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312db16e22c5fd8788bb695841d30456">&#9670;&#160;</a></span>Mix_StartTrack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_StartTrack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d58ae8fa29e1c03df23baeffb32b14c">Mix_Music</a> *</td>          <td class="paramname"><span class="paramname"><em>music</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>track</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a track in music object. </p>
<p>This only applies to GME music formats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">music</td><td>the music object. </td></tr>
    <tr><td class="paramname">track</td><td>the track number to play. 0 is the first track. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if failed or isn't implemented.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a3591d82e9975a21317865850644e1bf8" name="a3591d82e9975a21317865850644e1bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3591d82e9975a21317865850644e1bf8">&#9670;&#160;</a></span>Mix_UnregisterAllEffects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_UnregisterAllEffects </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly unregister all special effect functions. </p>
<p>You may not need to call this at all, unless you need to stop all effects from processing in the middle of a chunk's playback.</p>
<p>Note that this will also shut off some internal effect processing, since <a class="el" href="#a896c0ac1043249dfbf1bc758297f54f2" title="Set the panning of a channel.">Mix_SetPanning()</a> and others may use this API under the hood. This is called internally when a channel completes playback. Posteffects are never implicitly unregistered as they are for channels, but they may be explicitly unregistered through this function by specifying MIX_CHANNEL_POST for a channel.</p>
<p>Note that unlike most SDL and SDL_mixer functions, this function returns zero if there's an error, not on success. We apologize for the API design inconsistency here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to unregister all effects on, or MIX_CHANNEL_POST. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if error (no such channel), nonzero if all effects removed. Error messages can be retrieved from <a class="el" href="#ab29aa52963e2c1dd92888629c810c74f" title="Get last SDL_mixer error.">Mix_GetError()</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a3c460b5c391b7037156adcc47d5ba2c5" name="a3c460b5c391b7037156adcc47d5ba2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c460b5c391b7037156adcc47d5ba2c5">&#9670;&#160;</a></span>Mix_UnregisterEffect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_UnregisterEffect </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aed80ffef737d37eefc7354e0ebff8c1b">Mix_EffectFunc_t</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly unregister a special effect function. </p>
<p>You may not need to call this at all, unless you need to stop an effect from processing in the middle of a chunk's playback.</p>
<p>Posteffects are never implicitly unregistered as they are for channels (as the output stream does not have an end), but they may be explicitly unregistered through this function by specifying MIX_CHANNEL_POST for a channel.</p>
<p>Note that unlike most SDL and SDL_mixer functions, this function returns zero if there's an error, not on success. We apologize for the API design inconsistency here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to unregister an effect on, or MIX_CHANNEL_POST. </td></tr>
    <tr><td class="paramname">f</td><td>effect the callback stop calling in future mixing iterations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if error (no such channel or effect), nonzero if removed. Error messages can be retrieved from <a class="el" href="#ab29aa52963e2c1dd92888629c810c74f" title="Get last SDL_mixer error.">Mix_GetError()</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a41d2418a357057d2aabad338476e1b9a" name="a41d2418a357057d2aabad338476e1b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d2418a357057d2aabad338476e1b9a">&#9670;&#160;</a></span>Mix_Volume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_Volume </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the volume for a specific channel. </p>
<p>The volume must be between 0 (silence) and MIX_MAX_VOLUME (full volume). Note that MIX_MAX_VOLUME is 128. Values greater than MIX_MAX_VOLUME are clamped to MIX_MAX_VOLUME.</p>
<p>Specifying a negative volume will not change the current volume; as such, this can be used to query the current volume without making changes, as this function returns the previous (in this case, still-current) value.</p>
<p>If the specified channel is -1, this function sets the volume for all channels, and returns <em>the average</em> of all channels' volumes prior to this call.</p>
<p>The default volume for a channel is MIX_MAX_VOLUME (no attenuation).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel on set/query the volume on, or -1 for all channels. </td></tr>
    <tr><td class="paramname">volume</td><td>the new volume, between 0 and MIX_MAX_VOLUME, or -1 to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous volume. If the specified volume is -1, this returns the current volume. If <code>channel</code> is -1, this returns the average of all channels.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="a4d54b34877f1187d4789884cbaff8be2" name="a4d54b34877f1187d4789884cbaff8be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d54b34877f1187d4789884cbaff8be2">&#9670;&#160;</a></span>Mix_VolumeChunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_VolumeChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mix___chunk.html">Mix_Chunk</a> *</td>          <td class="paramname"><span class="paramname"><em>chunk</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the volume for a specific chunk. </p>
<p>In addition to channels having a volume setting, individual chunks also maintain a separate volume. Both values are considered when mixing, so both affect the final attenuation of the sound. This lets an app adjust the volume for all instances of a sound in addition to specific instances of that sound.</p>
<p>The volume must be between 0 (silence) and MIX_MAX_VOLUME (full volume). Note that MIX_MAX_VOLUME is 128. Values greater than MIX_MAX_VOLUME are clamped to MIX_MAX_VOLUME.</p>
<p>Specifying a negative volume will not change the current volume; as such, this can be used to query the current volume without making changes, as this function returns the previous (in this case, still-current) value.</p>
<p>The default volume for a chunk is MIX_MAX_VOLUME (no attenuation).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk</td><td>the chunk whose volume to adjust. </td></tr>
    <tr><td class="paramname">volume</td><td>the new volume, between 0 and MIX_MAX_VOLUME, or -1 to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous volume. If the specified volume is -1, this returns the current volume. If <code>chunk</code> is NULL, this returns -1.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
<a id="ab926fc25eab93de464ac7029e2125003" name="ab926fc25eab93de464ac7029e2125003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab926fc25eab93de464ac7029e2125003">&#9670;&#160;</a></span>Mix_VolumeMusic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DECLSPEC int SDLCALL Mix_VolumeMusic </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>volume</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the volume for the music channel. </p>
<p>The volume must be between 0 (silence) and MIX_MAX_VOLUME (full volume). Note that MIX_MAX_VOLUME is 128. Values greater than MIX_MAX_VOLUME are clamped to MIX_MAX_VOLUME.</p>
<p>Specifying a negative volume will not change the current volume; as such, this can be used to query the current volume without making changes, as this function returns the previous (in this case, still-current) value.</p>
<p>The default volume for music is MIX_MAX_VOLUME (no attenuation).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>the new volume, between 0 and MIX_MAX_VOLUME, or -1 to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous volume. If the specified volume is -1, this returns the current volume.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>This function is available since SDL_mixer 3.0.0. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
